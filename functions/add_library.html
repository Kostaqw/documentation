<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>add_library</title>
    <link href="../lib/bootstrap.min.css" rel="stylesheet">
    <link href="../css/styles.css" rel="stylesheet">
    <script src="../js/jquery-3.5.1.min.js"></script>
    <script src="../js/popper.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/scripts.js"></script>
</head>

<body>
    <div class="container">
        <h1 class="mt-4">add_library</h1>
        <div id="contents">
            <h2>Содержание</h2>
            <ul>
                <li><a href="#add_library">add_library</a></li>
                <li><a href="#normal-libraries">Обычные библиотеки</a></li>
                <li><a href="#object-libraries">Библиотеки объектов</a></li>
                <li><a href="#interface-libraries">Интерфейсные библиотеки</a></li>
                <li><a href="#imported-libraries">Импортированные библиотеки</a></li>
                <li><a href="#alias-libraries">Библиотеки псевдонимов</a></li>
                <li><a href="#see-also">Смотрите также</a></li>
            </ul>
        </div>

        <div id="add_library" class="mt-4">
            <h2>add_library</h2>
            <p>Добавьте библиотеку в проект, используя указанные исходные файлы.</p>
        </div>

        <div id="normal-libraries" class="mt-4">
            <h3>Обычные библиотеки</h3>
            <pre><code>add_library(&lt;name&gt; [&lt;type&gt;] [EXCLUDE_FROM_ALL] &lt;sources&gt;...)</code></pre>
            <p>Добавьте цель библиотеки с именем &lt;name&gt;, которая будет собрана из исходных файлов, указанных в вызове команды.</p>
            <p>Необязательный параметр &lt;type&gt; указывает тип создаваемой библиотеки:</p>
            <ul>
                <li><strong>STATIC</strong>: Архив объектных файлов для использования при компоновке других целей.</li>
                <li><strong>SHARED</strong>: Динамическая библиотека, которая может быть связана с другими целями и загружена во время выполнения.</li>
                <li><strong>MODULE</strong>: Плагин, который не может быть связан с другими целями, но может быть динамически загружен во время выполнения с помощью функции, подобной dlopen.</li>
            </ul>
            <p>Если параметр &lt;type&gt; не указан, по умолчанию используется STATIC или SHARED в зависимости от значения переменной BUILD_SHARED_LIBS.</p>
            <p>Опции:</p>
            <ul>
                <li><strong>EXCLUDE_FROM_ALL</strong>: Автоматически устанавливает свойство цели EXCLUDE_FROM_ALL. См. документацию по этому свойству цели для подробностей.</li>
            </ul>
            <p>Имя &lt;name&gt; соответствует логическому имени цели и должно быть уникальным в пределах проекта. Фактическое имя файла создаваемой библиотеки формируется на основе соглашений нативной платформы (например, lib&lt;name&gt;.a или &lt;name&gt;.lib).</p>
            <p>Новое в версии 3.1: аргументы источника для add_library могут использовать "выражения генератора" с синтаксисом $&lt;...&gt;. См. руководство cmake-generator-expressions(7) для доступных выражений.</p>
            <p>Новое в версии 3.11: исходные файлы могут быть опущены, если они добавляются позже с помощью target_sources().</p>
            <p>Для библиотек SHARED и MODULE свойство цели POSITION_INDEPENDENT_CODE автоматически устанавливается в ON. Библиотека SHARED может быть помечена свойством цели FRAMEWORK для создания фреймворка macOS.</p>
            <p>Новое в версии 3.8: Библиотека STATIC может быть помечена свойством цели FRAMEWORK для создания статического фреймворка.</p>
            <p>Если библиотека не экспортирует никаких символов, она не должна быть объявлена как SHARED библиотека. Например, ресурсная DLL для Windows или управляемая библиотека C++/CLI, не экспортирующая неуправляемых символов, должна быть библиотекой MODULE. Это связано с тем, что CMake ожидает, что библиотека SHARED всегда будет иметь ассоциированную импортируемую библиотеку в Windows.</p>
            <p>По умолчанию файл библиотеки будет создан в каталоге дерева сборки, соответствующем каталогу дерева исходных файлов, в котором был вызван командный вызов. См. документацию по свойствам цели ARCHIVE_OUTPUT_DIRECTORY, LIBRARY_OUTPUT_DIRECTORY и RUNTIME_OUTPUT_DIRECTORY для изменения этого местоположения. См. документацию по свойству цели OUTPUT_NAME для изменения части &lt;name&gt; конечного имени файла.</p>
            <p>См. руководство cmake-buildsystem(7) для получения дополнительной информации о определении свойств системы сборки.</p>
            <p>См. также HEADER_FILE_ONLY о том, что делать, если некоторые исходные файлы предобрабатываются, и вы хотите, чтобы исходные файлы были доступны из IDE.</p>
            <p>Изменено в версии 3.30: на платформах, которые не поддерживают динамические библиотеки, add_library теперь завершает вызовы для создания SHARED библиотек с ошибкой вместо автоматического преобразования их в STATIC библиотеки, как раньше. См. политику CMP0164.</p>
        </div>

        <div id="object-libraries" class="mt-4">
            <h3>Библиотеки объектов</h3>
            <pre><code>add_library(&lt;name&gt; OBJECT &lt;sources&gt;...)</code></pre>
            <p>Добавьте библиотеку объектов для компиляции исходных файлов без архивации или связывания их объектных файлов в библиотеку.</p>
            <p>Другие цели, созданные с помощью add_library или add_executable(), могут ссылаться на объекты, используя выражение формы $&lt;TARGET_OBJECTS:objlib&gt; как источник, где objlib - имя библиотеки объектов. Например:</p>
            <pre><code>add_library(... $&lt;TARGET_OBJECTS:objlib&gt; ...)</code></pre>
            <pre><code>add_executable(... $&lt;TARGET_OBJECTS:objlib&gt; ...)</code></pre>
            <p>включит объектные файлы objlib в библиотеку и исполняемый файл вместе с теми, которые скомпилированы из их собственных исходников. Библиотеки объектов могут содержать только компилируемые исходные файлы, заголовочные файлы и другие файлы, которые не повлияют на связывание обычной библиотеки (например, .txt). Они могут содержать пользовательские команды, генерирующие такие источники, но не команды PRE_BUILD, PRE_LINK или POST_BUILD. Некоторые нативные системы сборки (например, Xcode) могут не любить цели, содержащие только объектные файлы, поэтому рассмотрите возможность добавления хотя бы одного реального исходного файла в любую цель, которая ссылается на $&lt;TARGET_OBJECTS:objlib&gt;.</p>
            <p>Новое в версии 3.12: Библиотеки объектов могут быть связаны с target_link_libraries().</p>
        </div>

        <div id="interface-libraries" class="mt-4">
            <h3>Интерфейсные библиотеки</h3>
            <pre><code>add_library(&lt;name&gt; INTERFACE)</code></pre>
            <p>Добавьте цель интерфейсной библиотеки, которая может указывать требования к использованию для зависимых, но не компилирует исходные файлы и не производит артефакт библиотеки на диске.</p>
            <p>Интерфейсная библиотека без исходных файлов не включается как цель в сгенерированной системе сборки. Однако она может иметь установленные на нее свойства, и она может быть установлена и экспортирована. Обычно INTERFACE_* свойства заполняются на интерфейсной цели с помощью команд:</p>
            <ul>
                <li>set_property(),</li>
                <li>target_link_libraries(INTERFACE),</li>
                <li>target_link_options(INTERFACE),</li>
                <li>target_include_directories(INTERFACE),</li>
                <li>target_compile_options(INTERFACE),</li>
                <li>target_compile_definitions(INTERFACE), и</li>
                <li>target_sources(INTERFACE),</li>
            </ul>
            <p>а затем используется в качестве аргумента для target_link_libraries() как любая другая цель.</p>
            <p>Новое в версии 3.15: Интерфейсная библиотека может иметь свойства PUBLIC_HEADER и PRIVATE_HEADER. Заголовки, указанные этими свойствами, могут быть установлены с помощью команды install(TARGETS).</p>
            <pre><code>add_library(&lt;name&gt; INTERFACE [EXCLUDE_FROM_ALL] &lt;sources&gt;...)</code></pre>
            <p>Новое в версии 3.19.</p>
            <p>Добавьте цель интерфейсной библиотеки с исходными файлами (в дополнение к требованиям к использованию и свойствам, как описано в вышеуказанной сигнатуре). Исходные файлы могут быть указаны непосредственно в вызове add_library или добавлены позже вызовами target_sources() с ключевыми словами PRIVATE или PUBLIC.</p>
            <p>Если у интерфейсной библиотеки есть исходные файлы (т.е. установлено свойство цели SOURCES) или наборы заголовков (т.е. установлено свойство цели HEADER_SETS), она будет отображаться в сгенерированной системе сборки как цель сборки, подобная цели, определенной командой add_custom_target(). Она не компилирует никаких исходников, но содержит правила сборки для пользовательских команд, созданных командой add_custom_command().</p>
            <p>Опции:</p>
            <ul>
                <li><strong>EXCLUDE_FROM_ALL</strong>: Автоматически устанавливает свойство цели EXCLUDE_FROM_ALL. См. документацию по этому свойству цели для подробностей.</li>
            </ul>
            <p>Примечание: в большинстве сигнатур команд, где появляется ключевое слово INTERFACE, элементы, перечисленные после него, становятся частью требований к использованию этой цели и не являются частью собственных настроек цели. Однако в этой сигнатуре add_library ключевое слово INTERFACE относится только к типу библиотеки. Исходники, указанные после него в вызове add_library, являются PRIVATE для интерфейсной библиотеки и не отображаются в свойстве цели INTERFACE_SOURCES.</p>
        </div>

        <div id="imported-libraries" class="mt-4">
            <h3>Импортированные библиотеки</h3>
            <pre><code>add_library(&lt;name&gt; &lt;type&gt; IMPORTED [GLOBAL])</code></pre>
            <p>Добавьте цель импортированной библиотеки с именем &lt;name&gt;. Имя цели может использоваться, как любая цель, построенная в проекте, за исключением того, что по умолчанию оно видно только в каталоге, в котором оно создано, и ниже.</p>
            <p>Параметр &lt;type&gt; должен быть одним из:</p>
            <ul>
                <li><strong>STATIC, SHARED, MODULE, UNKNOWN</strong>: Ссылается на файл библиотеки, расположенный за пределами проекта. Свойство цели IMPORTED_LOCATION (или его вариант для конкретной конфигурации IMPORTED_LOCATION_&lt;CONFIG&gt;) указывает местоположение основного файла библиотеки на диске:</li>
                <li>Для библиотеки SHARED на большинстве не-Windows платформ, основной файл библиотеки - это файл .so или .dylib, используемый как компоновщиками, так и динамическими загрузчиками. Если у ссылаемого файла библиотеки есть SONAME (или на macOS, LC_ID_DYLIB, начинающийся с @rpath/), значение этого поля должно быть установлено в свойство цели IMPORTED_SONAME. Если у ссылаемого файла библиотеки нет SONAME, но платформа поддерживает это, то свойство цели IMPORTED_NO_SONAME должно быть установлено.</li>
                <li>Для библиотеки SHARED на Windows, свойство цели IMPORTED_IMPLIB (или его вариант для конкретной конфигурации IMPORTED_IMPLIB_&lt;CONFIG&gt;) указывает местоположение файла импортируемой библиотеки DLL (.lib или .dll.a) на диске, и IMPORTED_LOCATION - местоположение библиотеки выполнения .dll (и это необязательно, но необходимо для выражения генератора TARGET_RUNTIME_DLLS).</li>
                <li>Дополнительные требования к использованию могут быть указаны в свойствах INTERFACE_*.</li>
                <li>Тип библиотеки UNKNOWN обычно используется только в реализации Find Modules. Он позволяет использовать путь к импортированной библиотеке (часто найденной с помощью команды find_library()), не зная, какой тип библиотеки это. Это особенно полезно в Windows, где статическая библиотека и импортируемая библиотека DLL имеют одно и то же расширение файла.</li>
                <li><strong>OBJECT</strong>: Ссылается на набор объектных файлов, расположенных за пределами проекта. Свойство цели IMPORTED_OBJECTS (или его вариант для конкретной конфигурации IMPORTED_OBJECTS_&lt;CONFIG&gt;) указывает местоположение объектных файлов на диске. Дополнительные требования к использованию могут быть указаны в свойствах INTERFACE_*.</li>
                <li><strong>INTERFACE</strong>: Не ссылается ни на библиотеку, ни на объектные файлы на диске, но может указывать требования к использованию в свойствах INTERFACE_*.</li>
            </ul>
            <p>Опции:</p>
            <ul>
                <li><strong>GLOBAL</strong>: Сделать имя цели глобально видимым.</li>
            </ul>
            <p>Правила для сборки импортированных целей не генерируются, и свойство цели IMPORTED имеет значение True. Импортированные библиотеки полезны для удобной ссылки из команд, таких как target_link_libraries().</p>
            <p>Подробности о импортированной библиотеке задаются установкой свойств, имена которых начинаются с IMPORTED_ и INTERFACE_. См. документацию по таким свойствам для получения дополнительной информации.</p>
        </div>

        <div id="alias-libraries" class="mt-4">
            <h3>Библиотеки псевдонимов</h3>
            <pre><code>add_library(&lt;name&gt; ALIAS &lt;target&gt;)</code></pre>
            <p>Создает цель псевдонима, так что &lt;name&gt; может использоваться для ссылки на &lt;target&gt; в последующих командах. &lt;name&gt; не отображается в сгенерированной системе сборки как цель make. &lt;target&gt; не может быть псевдонимом.</p>
            <p>Новое в версии 3.11: Псевдоним может ссылаться на глобальную импортированную цель.</p>
            <p>Новое в версии 3.18: Псевдоним может ссылаться на не-глобальную импортированную цель. Такой псевдоним ограничен директорией, в которой он создан, и ниже. Свойство цели ALIAS_GLOBAL можно использовать для проверки, является ли псевдоним глобальным или нет.</p>
            <p>Цели ALIAS могут использоваться как связываемые цели и как цели для чтения свойств. Они также могут быть проверены на существование с помощью обычной подкоманды if(TARGET). &lt;name&gt; не может использоваться для изменения свойств &lt;target&gt;, т.е. не может использоваться как операнд команд set_property(), set_target_properties(), target_link_libraries() и т.д. Цель ALIAS не может быть установлена или экспортирована.</p>
        </div>

        <div id="see-also" class="mt-4">
            <h3>Смотрите также</h3>
            <p><a href="https://cmake.org/cmake/help/latest/command/add_executable.html">add_executable()</a></p>
        </div>
    </div>
</body>

</html>
