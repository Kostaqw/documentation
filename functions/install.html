<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>install</title>
    <link href="../lib/bootstrap.min.css" rel="stylesheet">
    <link href="../css/styles.css" rel="stylesheet">
    <script src="../js/jquery-3.5.1.min.js"></script>
    <script src="../js/popper.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/scripts.js"></script>
</head>

<body>
    <div class="container">
        <div class="container mt-5">
            <div class="container mt-4">
                <h1>Команда install</h1>

                <h2>Содержание</h2>
                <ul>
                    <li><a href="#install">install</a></li>
                    <ul>
                        <li><a href="#synopsis">Синопсис</a></li>
                        <li><a href="#introduction">Введение</a></li>
                        <li><a href="#signatures">Сигнатуры</a></li>
                        <li><a href="#examples">Примеры</a></li>
                        <ul>
                            <li><a href="#example1">Пример: Установка целей с компонентами Per-Artifact</a></li>
                            <li><a href="#example2">Пример: Установка целей в назначения Per-Config</a></li>
                        </ul>
                        <li><a href="#generated-script">Сгенерированный скрипт установки</a></li>
                    </ul>
                </ul>

                <h3 id="synopsis">Синопсис</h3>
                <p>install(TARGETS &lt;target&gt;... [...])</p>
                <p>install(IMPORTED_RUNTIME_ARTIFACTS &lt;target&gt;... [...])</p>
                <p>install({FILES | PROGRAMS} &lt;file&gt;... [...])</p>
                <p>install(DIRECTORY &lt;dir&gt;... [...])</p>
                <p>install(SCRIPT &lt;file&gt; [...])</p>
                <p>install(CODE &lt;code&gt; [...])</p>
                <p>install(EXPORT &lt;export-name&gt; [...])</p>
                <p>install(RUNTIME_DEPENDENCY_SET &lt;set-name&gt; [...])</p>

                <h3 id="introduction">Введение</h3>
                <p>Эта команда генерирует правила установки для проекта. Правила установки, указанные вызовами команды
                    install() в каталоге с исходным кодом, выполняются в порядке установки.</p>
                <p><strong>Изменено в версии 3.14:</strong> Правила установки в подкаталогах, добавленные вызовами
                    команды add_subdirectory(), выполняются в порядке, указанном в родительском каталоге (см. политику
                    CMP0082).</p>
                <p><strong>Изменено в версии 3.22:</strong> Переменная окружения CMAKE_INSTALL_MODE может переопределять
                    поведение копирования по умолчанию команды install().</p>

                <p>Для этой команды существует несколько сигнатур. Некоторые из них определяют параметры установки для
                    файлов и целей. Общие параметры, которые используются в нескольких сигнатурах, описаны здесь, но они
                    действительны только для тех сигнатур, которые их указывают. Общие параметры включают:</p>

                <h4>DESTINATION &lt;dir&gt;</h4>
                <p>Указывает каталог на диске, в который будет установлен файл. &lt;dir&gt; должен быть относительным
                    путем. Абсолютный путь допустим, но не рекомендуется.</p>
                <p>При указании относительного пути он интерпретируется относительно значения переменной
                    CMAKE_INSTALL_PREFIX. Префикс может быть перемещен во время установки с использованием механизма
                    DESTDIR, описанного в документации по переменной CMAKE_INSTALL_PREFIX.</p>
                <p>Так как абсолютные пути не работают с параметром --prefix команды cmake --install или с генераторами
                    установщиков cpack, настоятельно рекомендуется использовать относительные пути для наилучшей
                    поддержки со стороны сопровождающих пакетов. В частности, нет необходимости делать пути абсолютными
                    путем добавления CMAKE_INSTALL_PREFIX; этот префикс используется по умолчанию, если DESTINATION
                    является относительным путем.</p>
                <p>Если указан абсолютный путь (с ведущим слэшем или буквой диска), он используется дословно.</p>

                <h4>PERMISSIONS &lt;permission&gt;...</h4>
                <p>Указывает права доступа для устанавливаемых файлов. Допустимые права: OWNER_READ, OWNER_WRITE,
                    OWNER_EXECUTE, GROUP_READ, GROUP_WRITE, GROUP_EXECUTE, WORLD_READ, WORLD_WRITE, WORLD_EXECUTE,
                    SETUID и SETGID. Права, которые не имеют смысла на определенных платформах, игнорируются на этих
                    платформах.</p>
                <p>Если этот параметр используется несколько раз в одном вызове, список прав накапливается. Если вызов
                    install(TARGETS) использует аргументы &lt;artifact-kind&gt;, для каждого типа артефакта
                    накапливается отдельный список прав.</p>

                <h4>CONFIGURATIONS &lt;config&gt;...</h4>
                <p>Указывает список конфигураций сборки, для которых применяется правило установки (Debug, Release и
                    т.д.).</p>
                <p>Если этот параметр используется несколько раз в одном вызове, его список конфигураций накапливается.
                    Если вызов install(TARGETS) использует аргументы &lt;artifact-kind&gt;, для каждого типа артефакта
                    накапливается отдельный список конфигураций.</p>

                <h4>COMPONENT &lt;component&gt;</h4>
                <p>Указывает имя компонента установки, с которым связано правило установки, например, Runtime или
                    Development. Во время установки компонента по имени будут выполнены только те правила установки,
                    которые связаны с данным именем компонента. Во время полной установки все компоненты
                    устанавливаются, если они не отмечены как EXCLUDE_FROM_ALL. Если COMPONENT не указан, создается
                    компонент по умолчанию "Unspecified". Имя компонента по умолчанию можно контролировать с помощью
                    переменной CMAKE_INSTALL_DEFAULT_COMPONENT_NAME.</p>

                <h4>EXCLUDE_FROM_ALL</h4>
                <p><strong>Новое в версии 3.6.</strong></p>
                <p>Указывает, что файл исключается из полной установки и устанавливается только в рамках установки
                    компонента.</p>

                <h4>RENAME &lt;name&gt;</h4>
                <p>Указывает имя для устанавливаемого файла, которое может отличаться от оригинального файла.
                    Переименование разрешено только при установке одного файла с помощью команды.</p>

                <h4>OPTIONAL</h4>
                <p>Указывает, что отсутствие файла для установки не является ошибкой.</p>

                <p><strong>Новое в версии 3.1:</strong> Сигнатуры команд, которые устанавливают файлы, могут выводить
                    сообщения во время установки. Используйте переменную CMAKE_INSTALL_MESSAGE, чтобы контролировать,
                    какие сообщения выводятся.</p>
                <p><strong>Новое в версии 3.11:</strong> Многие варианты команды install() автоматически создают
                    каталоги, содержащие устанавливаемые файлы. Если установлена переменная
                    CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS, эти каталоги будут создаваться с указанными правами. В
                    противном случае они будут созданы согласно правилам uname на платформах, похожих на Unix. Платформы
                    Windows не затронуты.</p>

                <h3 id="signatures">Сигнатуры</h3>

                <h4>install(TARGETS &lt;target&gt;... [...])</h4>
                <p>Устанавливает целевые выходные артефакты и связанные файлы:</p>
                <pre><code>install(TARGETS &lt;target&gt;... [EXPORT &lt;export-name&gt;]
                [RUNTIME_DEPENDENCIES &lt;arg&gt;...|RUNTIME_DEPENDENCY_SET &lt;set-name&gt;]
                [&lt;artifact-option&gt;...]
                [&lt;artifact-kind&gt; &lt;artifact-option&gt;...]...
                [INCLUDES DESTINATION [&lt;dir&gt; ...]])</code></pre>

                <p>Группа параметров <code>&lt;artifact-option&gt;...</code> может содержать:</p>
                <h4>install(TARGETS &lt;target&gt;... [...])</h4>
                <p>Устанавливает целевые выходные артефакты и связанные файлы:</p>
                <pre><code>[DESTINATION &lt;dir&gt;]
[PERMISSIONS &lt;permission&gt;...]
[CONFIGURATIONS &lt;config&gt;...]
[COMPONENT &lt;component&gt;]
[NAMELINK_COMPONENT &lt;component&gt;]
[OPTIONAL] [EXCLUDE_FROM_ALL]
[NAMELINK_ONLY|NAMELINK_SKIP]</code></pre>

                <p>Первая группа <code>&lt;artifact-option&gt;...</code> применяется к выходным артефактам цели, которые
                    не имеют выделенной группы, указанной позже в том же вызове.</p>

                <p>Каждая группа <code>&lt;artifact-kind&gt; &lt;artifact-option&gt;...</code> применяется к выходным
                    артефактам указанного типа:</p>

                <h4>ARCHIVE</h4>
                <p>Целевые артефакты этого типа включают:</p>
                <ul>
                    <li>Статические библиотеки (за исключением macOS, когда они помечены как FRAMEWORK, см. ниже);</li>
                    <li>Импортные библиотеки DLL (на всех платформах на базе Windows, включая Cygwin; они имеют
                        расширение .lib, в отличие от библиотек .dll, которые относятся к RUNTIME);</li>
                    <li>На AIX, файл импорта компоновщика, создаваемый для исполняемых файлов с включенной опцией
                        ENABLE_EXPORTS;</li>
                    <li>На macOS, файл импорта компоновщика, создаваемый для разделяемых библиотек с включенной опцией
                        ENABLE_EXPORTS (кроме тех, что помечены как FRAMEWORK, см. ниже).</li>
                </ul>

                <h4>LIBRARY</h4>
                <p>Целевые артефакты этого типа включают:</p>
                <ul>
                    <li>Разделяемые библиотеки, за исключением:</li>
                    <ul>
                        <li>DLL (эти библиотеки относятся к RUNTIME, см. ниже);</li>
                        <li>на macOS, когда они помечены как FRAMEWORK (см. ниже).</li>
                    </ul>
                </ul>

                <h4>RUNTIME</h4>
                <p>Целевые артефакты этого типа включают:</p>
                <ul>
                    <li>Исполняемые файлы (за исключением macOS, когда они помечены как MACOSX_BUNDLE, см. BUNDLE ниже);
                    </li>
                    <li>DLL (на всех платформах на базе Windows, включая Cygwin; обратите внимание, что сопутствующие
                        импортные библиотеки относятся к типу ARCHIVE).</li>
                </ul>

                <h4>OBJECTS</h4>
                <p><strong>Новое в версии 3.9.</strong></p>
                <p>Файлы объектов, связанные с объектными библиотеками.</p>

                <h4>FRAMEWORK</h4>
                <p>Как статические, так и разделяемые библиотеки, помеченные свойством FRAMEWORK, рассматриваются как
                    цели типа FRAMEWORK на macOS.</p>

                <h4>BUNDLE</h4>
                <p>Исполняемые файлы, помеченные свойством MACOSX_BUNDLE, рассматриваются как цели типа BUNDLE на macOS.
                </p>

                <h4>PUBLIC_HEADER</h4>
                <p>Любые файлы PUBLIC_HEADER, связанные с библиотекой, устанавливаются в место назначения, указанное
                    аргументом PUBLIC_HEADER на платформах, отличных от Apple. Правила, определенные этим аргументом,
                    игнорируются для библиотек FRAMEWORK на платформах Apple, так как связанные файлы устанавливаются в
                    соответствующие места внутри папки фреймворка. См. подробности в разделе PUBLIC_HEADER.</p>

                <h4>PRIVATE_HEADER</h4>
                <p>Аналогично PUBLIC_HEADER, но для файлов PRIVATE_HEADER. См. подробности в разделе PRIVATE_HEADER.</p>

                <h4>RESOURCE</h4>
                <p>Аналогично PUBLIC_HEADER и PRIVATE_HEADER, но для файлов RESOURCE. См. подробности в разделе
                    RESOURCE.</p>

                <h4>FILE_SET &lt;set-name&gt;</h4>
                <p><strong>Новое в версии 3.23.</strong></p>
                <p>Наборы файлов определяются командой target_sources(FILE_SET). Если набор файлов
                    <code>&lt;set-name&gt;</code> существует и является PUBLIC или INTERFACE, любые файлы в наборе
                    устанавливаются под указанное место назначения (см. ниже). Структура каталогов относительно базовых
                    директорий набора файлов сохраняется. Например, файл, добавленный в набор файлов как
                    /blah/include/myproj/here.h с базовым каталогом /blah/include, будет установлен в myproj/here.h ниже
                    места назначения.
                </p>

                <h4>CXX_MODULES_BMI</h4>
                <p><strong>Новое в версии 3.28.</strong></p>
                <p>Любые файлы модулей из C++ модулей из PUBLIC источников в наборе файлов типа CXX_MODULES будут
                    установлены в указанное место назначения. Все модули размещаются непосредственно в месте назначения,
                    так как структура каталогов не зависит от имен модулей. Пустое место назначения может использоваться
                    для подавления установки этих файлов (для использования в универсальном коде).</p>

                <h3>Дополнительные параметры для целевых типов:</h3>
                <p>Для обычных исполняемых файлов, статических библиотек и разделяемых библиотек аргумент DESTINATION не
                    является обязательным. Для этих типов целей, когда DESTINATION не указан, по умолчанию используется
                    место назначения, взятое из соответствующей переменной из GNUInstallDirs, или задано встроенное
                    значение по умолчанию, если переменная не определена. То же самое касается наборов файлов и
                    публичных и частных заголовков, связанных с установленными целями через свойства целей PUBLIC_HEADER
                    и PRIVATE_HEADER. Место назначения всегда должно быть указано для модульных библиотек, Apple bundles
                    и frameworks. Место назначения может быть опущено для интерфейсных и объектных библиотек, но они
                    обрабатываются иначе (см. обсуждение этой темы ближе к концу этого раздела).</p>

                <h4>Аргументы для целей на платформах DLL:</h4>
                <p>Для разделяемых библиотек на платформах DLL, если ни RUNTIME, ни ARCHIVE назначения не указаны, оба
                    компонента RUNTIME и ARCHIVE устанавливаются в их места назначения по умолчанию. Если указано место
                    назначения для RUNTIME или ARCHIVE, компонент устанавливается в указанное место назначения, а другой
                    компонент не устанавливается. Если указаны оба назначения, то оба компонента устанавливаются в
                    соответствующие места назначения.</p>

                <h4>Таблица соответствия типов целей и переменных GNUInstallDirs:</h4>
                <p>В следующей таблице показаны типы целей с их ассоциированными переменными и встроенными значениями по
                    умолчанию, которые применяются, когда место назначения не указано:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Тип цели</th>
                            <th>Переменная GNUInstallDirs</th>
                            <th>Встроенное значение по умолчанию</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>RUNTIME</td>
                            <td>${CMAKE_INSTALL_BINDIR}</td>
                            <td>bin</td>
                        </tr>
                        <tr>
                            <td>LIBRARY</td>
                            <td>${CMAKE_INSTALL_LIBDIR}</td>
                            <td>lib</td>
                        </tr>
                        <tr>
                            <td>ARCHIVE</td>
                            <td>${CMAKE_INSTALL_LIBDIR}</td>
                            <td>lib</td>
                        </tr>
                        <tr>
                            <td>PRIVATE_HEADER</td>
                            <td>${CMAKE_INSTALL_INCLUDEDIR}</td>
                            <td>include</td>
                        </tr>
                        <tr>
                            <td>PUBLIC_HEADER</td>
                            <td>${CMAKE_INSTALL_INCLUDEDIR}</td>
                            <td>include</td>
                        </tr>
                        <tr>
                            <td>FILE_SET (тип HEADERS)</td>
                            <td>${CMAKE_INSTALL_INCLUDEDIR}</td>
                            <td>include</td>
                        </tr>
                    </tbody>
                </table>

                <p>Проекты, стремящиеся следовать общей практике установки заголовков в подкаталог, специфичный для
                    проекта, могут предпочесть использовать наборы файлов с соответствующими путями и базовыми
                    директориями. В противном случае, они должны предоставить DESTINATION вместо того, чтобы полагаться
                    на вышеуказанные параметры (см. следующий пример ниже).</p>

                <p>Чтобы пакеты соответствовали политике файловой системы дистрибутивов, если проекты должны указать
                    DESTINATION, настоятельно рекомендуется использовать путь, который начинается с соответствующей
                    относительной переменной GNUInstallDirs. Это позволяет менеджерам пакетов контролировать место
                    установки, устанавливая соответствующие переменные кэша. В следующем примере показано, как
                    статическая библиотека устанавливается в место назначения по умолчанию, предоставленное
                    GNUInstallDirs, но с заголовками, установленными в подкаталог, специфичный для проекта, без
                    использования наборов файлов:</p>

                <pre><code>add_library(mylib STATIC ...)
                set_target_properties(mylib PROPERTIES PUBLIC_HEADER mylib.h)
                include(GNUInstallDirs)
                install(TARGETS mylib
                        PUBLIC_HEADER
                        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/myproj
                )</code></pre>

                <h4>Дополнительные аргументы для целевых типов:</h4>

                <p>В дополнение к общим параметрам, перечисленным выше, каждая цель может принимать следующие
                    дополнительные аргументы:</p>

                <h4>NAMELINK_COMPONENT</h4>

                <p><strong>Новое в версии 3.12.</strong></p>
                <p>На некоторых платформах у версии разделяемой библиотеки есть символическая ссылка, такая как:</p>
                <pre><code>lib&lt;name&gt;.so -> lib&lt;name&gt;.so.1</code></pre>
                <p>где <code>lib&lt;name&gt;.so.1</code> - это имя библиотеки, а <code>lib&lt;name&gt;.so</code> -
                    "namelink", позволяющий компоновщикам найти библиотеку при использовании параметра
                    <code>-l&lt;name&gt;</code>. Опция <code>NAMELINK_COMPONENT</code> аналогична опции
                    <code>COMPONENT</code>, но изменяет компонент установки namelink для разделяемой библиотеки, если он
                    создается. Если не указано, по умолчанию используется значение <code>COMPONENT</code>. Ошибкой
                    является использование этого параметра вне блока <code>LIBRARY</code>.
                </p>

                <p><strong>Изменено в версии 3.27:</strong> Этот параметр также может использоваться для блока
                    <code>ARCHIVE</code> для управления файлом импорта компоновщика, созданного на macOS, для
                    разделяемых библиотек с включенной опцией ENABLE_EXPORTS.
                </p>

                <p>См. пример: Установка целей с компонентами на артефакт для примера использования NAMELINK_COMPONENT.
                </p>

                <p>Эта опция обычно используется для менеджеров пакетов, которые имеют отдельные пакеты для времени
                    выполнения и разработки. Например, в системах Debian ожидается, что библиотека будет находиться в
                    пакете времени выполнения, а заголовки и namelink будут находиться в пакете разработки.</p>

                <p>См. свойства цели <code>VERSION</code> и <code>SOVERSION</code> для деталей по созданию версионных
                    разделяемых библиотек.</p>
            </div>

            <h4>NAMELINK_ONLY</h4>
            <p>
                Этот параметр приводит к установке только namelink при установке целевой библиотеки. На платформах, где
                версии общих библиотек не имеют namelink, или когда библиотека не имеет версий, параметр NAMELINK_ONLY
                ничего не устанавливает. Ошибка использовать этот параметр вне блока LIBRARY.
            </p>
            <p>
                Изменено в версии 3.27: Этот параметр также можно использовать для блока ARCHIVE для управления файлом
                импорта компоновщика, созданным в macOS, для общих библиотек с включенным ENABLE_EXPORTS.
            </p>
            <p>
                Если задан NAMELINK_ONLY, для указания компонента установки namelink можно использовать либо
                NAMELINK_COMPONENT, либо COMPONENT, но предпочтительно использовать COMPONENT.
            </p>

            <h4>NAMELINK_SKIP</h4>
            <p>
                Похож на NAMELINK_ONLY, но имеет противоположный эффект: он приводит к установке файлов библиотеки,
                кроме namelink, при установке целевой библиотеки. Если не указаны ни NAMELINK_ONLY, ни NAMELINK_SKIP,
                устанавливаются обе части. На платформах, где версии общих библиотек не имеют символических ссылок, или
                когда библиотека не имеет версий, NAMELINK_SKIP устанавливает библиотеку. Ошибка использовать этот
                параметр вне блока LIBRARY.
            </p>
            <p>
                Изменено в версии 3.27: Этот параметр также можно использовать для блока ARCHIVE для управления файлом
                импорта компоновщика, созданным в macOS, для общих библиотек с включенным ENABLE_EXPORTS.
            </p>
            <p>
                Если указан NAMELINK_SKIP, параметр NAMELINK_COMPONENT не имеет эффекта. Не рекомендуется использовать
                NAMELINK_SKIP вместе с NAMELINK_COMPONENT.
            </p>

            <h4>Команда install(TARGETS) также может принимать следующие параметры на верхнем уровне:</h4>

            <h5>EXPORT</h5>
            <p>
                Этот параметр связывает установленные целевые файлы с экспортом под названием
                <em>&lt;export-name&gt;</em>. Он должен появиться перед любыми опциями целевого назначения. Чтобы
                фактически установить сам экспортный файл, вызовите <code>install(EXPORT)</code>, документированную
                ниже. См. документацию по свойству цели EXPORT_NAME для изменения имени экспортируемой цели.
            </p>
            <p>
                Если используется EXPORT и цели включают наборы файлов PUBLIC или INTERFACE, все они должны быть указаны
                с аргументами FILE_SET. Все наборы файлов PUBLIC или INTERFACE, связанные с целью, включаются в экспорт.
            </p>

            <h5>INCLUDES DESTINATION</h5>
            <p>
                Этот параметр указывает список каталогов, которые будут добавлены к свойству цели
                <code>INTERFACE_INCLUDE_DIRECTORIES</code> при экспорте командой <code>install(EXPORT)</code>. Если
                указан относительный путь, он трактуется как относительный к <code>$&lt;INSTALL_PREFIX&gt;</code>.
            </p>

            <h5>RUNTIME_DEPENDENCY_SET <em>&lt;set-name&gt;</em></h5>
            <p>
                Новое в версии 3.21.
            </p>
            <p>
                Этот параметр приводит к добавлению всех зависимостей выполнения установленных исполняемых файлов, общих
                библиотек и модульных целей в указанный набор зависимостей выполнения. Этот набор затем можно установить
                с помощью команды <code>install(RUNTIME_DEPENDENCY_SET)</code>.
            </p>
            <p>
                Эти ключевые слова и ключевое слово <code>RUNTIME_DEPENDENCIES</code> взаимоисключающие.
            </p>

            <h5>RUNTIME_DEPENDENCIES <em>&lt;arg&gt;...</em></h5>
            <p>
                Новое в версии 3.21.
            </p>
            <p>
                Этот параметр приводит к установке всех зависимостей выполнения установленных исполняемых файлов, общих
                библиотек и модулей вместе с самими целями. Аргументы <code>RUNTIME</code>, <code>LIBRARY</code>,
                <code>FRAMEWORK</code> и <code>generic</code> используются для определения свойств (например,
                DESTINATION, COMPONENT) установки этих зависимостей.
            </p>
            <p>
                <code>RUNTIME_DEPENDENCIES</code> семантически эквивалентен следующей паре вызовов:
            </p>
            <pre><code>
            install(TARGETS ... RUNTIME_DEPENDENCY_SET &lt;set-name&gt;)
            install(RUNTIME_DEPENDENCY_SET &lt;set-name&gt; &lt;arg&gt;...)
            </code></pre>
            <p>
                где <em>&lt;set-name&gt;</em> будет случайно сгенерированным именем набора. <em>&lt;arg&gt;...</em>
                может включать любые из следующих ключевых слов, поддерживаемых командой
                <code>install(RUNTIME_DEPENDENCY_SET)</code>:
            </p>
            <ul>
                <li>DIRECTORIES</li>
                <li>PRE_INCLUDE_REGEXES</li>
                <li>PRE_EXCLUDE_REGEXES</li>
                <li>POST_INCLUDE_REGEXES</li>
                <li>POST_EXCLUDE_REGEXES</li>
                <li>POST_INCLUDE_FILES</li>
                <li>POST_EXCLUDE_FILES</li>
            </ul>
            <p>
                Ключевые слова <code>RUNTIME_DEPENDENCIES</code> и <code>RUNTIME_DEPENDENCY_SET</code>
                взаимоисключающие.
            </p>

            <h4>Библиотеки интерфейса</h4>
            <p>
                Библиотеки интерфейса могут быть перечислены среди целей для установки. Они не устанавливают артефакты,
                но будут включены в связанный EXPORT. Если библиотеки объектов указаны, но не имеют назначения для своих
                объектных файлов, они будут экспортированы как библиотеки интерфейса. Это достаточно для удовлетворения
                транзитивных требований к использованию других целей, которые связываются с библиотеками объектов в
                своей реализации.
            </p>
            <p>
                Установка цели с установленным значением свойства <code>EXCLUDE_FROM_ALL</code> равным TRUE имеет
                неопределенное поведение.
            </p>
            <p>
                Новое в версии 3.3: Путь назначения установки, указанный в аргументе <code>DESTINATION</code>, может
                использовать "генераторные выражения" с синтаксисом <code>$&lt;...&gt;</code>. См. руководство
                <em>cmake-generator-expressions(7)</em> для получения доступных выражений.
            </p>
            <p>
                Новое в версии 3.13: <code>install(TARGETS)</code> может устанавливать цели, которые были созданы в
                других каталогах. При использовании таких правил установки между каталогами, запуск
                <code>make install</code> (или аналогичного) из подкаталога не гарантирует, что цели из других каталогов
                актуальны. Вы можете использовать <code>target_link_libraries()</code> или
                <code>add_dependencies()</code>, чтобы убедиться, что такие цели вне каталога построены до выполнения
                подкаталог-специфичных правил установки.
            </p>

            <h4>install(IMPORTED_RUNTIME_ARTIFACTS <em>&lt;target&gt;...</em> [...])</h4>
            <p>
                Новое в версии 3.21.
            </p>
            <p>
                Устанавливает артефакты выполнения импортированных целей:
            </p>
            <pre><code>
            install(IMPORTED_RUNTIME_ARTIFACTS &lt;target&gt;...
                    [RUNTIME_DEPENDENCY_SET &lt;set-name&gt;]
                    [[LIBRARY|RUNTIME|FRAMEWORK|BUNDLE]
                     [DESTINATION &lt;dir&gt;]
                     [PERMISSIONS &lt;permission&gt;...]
                     [CONFIGURATIONS &lt;config&gt;...]
                     [COMPONENT &lt;component&gt;]
                     [OPTIONAL] [EXCLUDE_FROM_ALL]
                    ] [...]
                    )
            </code></pre>
            <p>
                Форма <code>IMPORTED_RUNTIME_ARTIFACTS</code> определяет правила установки артефактов выполнения
                импортированных целей. Проекты могут делать это, если они хотят интегрировать внешние исполняемые файлы
                или модули в свою установку. Аргументы <code>LIBRARY</code>, <code>RUNTIME</code>,
                <code>FRAMEWORK</code> и <code>BUNDLE</code> имеют те же семантики, что и в режиме <code>TARGETS</code>.
                Устанавливаются только артефакты выполнения импортированных целей (за исключением случаев с библиотеками
                FRAMEWORK, исполняемыми файлами MACOSX_BUNDLE и пакетами BUNDLE CFBundles). Например, заголовки и
                импортируемые библиотеки, связанные с DLL, не устанавливаются. В случае с библиотеками FRAMEWORK,
                исполняемыми файлами MACOSX_BUNDLE и пакетами BUNDLE CFBundles устанавливается весь каталог.
            </p>
            <p>
                Параметр <code>RUNTIME_DEPENDENCY_SET</code> приводит к добавлению артефактов выполнения импортированных
                исполняемых файлов, общих библиотек и модульных библиотек в набор зависимостей выполнения
                <em>&lt;set-name&gt;</em>. Этот набор затем можно установить с помощью команды
                <code>install(RUNTIME_DEPENDENCY_SET)</code>.
            </p>

            <h4>install(FILES <em>&lt;file&gt;...</em> [...])</h4>
            <h4>install(PROGRAMS <em>&lt;program&gt;...</em> [...])</h4>
            <div class="alert alert-info">
                <strong>Примечание:</strong>
                Если вы устанавливаете заголовочные файлы, рассмотрите возможность использования наборов файлов,
                определенных командой <code>target_sources(FILE_SET)</code>. Наборы файлов связывают заголовки с целью,
                и они устанавливаются как часть этой цели.
            </div>
            <p>
                Устанавливает файлы или программы:
            </p>
            <pre><code>
            install(&lt;FILES|PROGRAMS&gt; &lt;file&gt;...
                    TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;
                    [PERMISSIONS &lt;permission&gt;...]
                    [CONFIGURATIONS &lt;config&gt;...]
                    [COMPONENT &lt;component&gt;]
                    [RENAME &lt;name&gt;] [OPTIONAL] [EXCLUDE_FROM_ALL])
            </code></pre>
            <p>
                Форма <code>FILES</code> определяет правила установки файлов для проекта. Имена файлов, указанные в виде
                относительных путей, интерпретируются относительно текущего каталога исходных файлов. Файлы,
                установленные с помощью этой формы, по умолчанию получают права доступа <code>OWNER_WRITE</code>,
                <code>OWNER_READ</code>, <code>GROUP_READ</code> и <code>WORLD_READ</code>, если не указан аргумент
                <code>PERMISSIONS</code>.
            </p>
            <p>
                Форма <code>PROGRAMS</code> идентична форме <code>FILES</code>, за исключением того, что права доступа
                по умолчанию для устанавливаемого файла также включают <code>OWNER_EXECUTE</code>,
                <code>GROUP_EXECUTE</code> и <code>WORLD_EXECUTE</code>. Эта форма предназначена для установки программ,
                которые не являются целями, например, shell-скриптов. Используйте форму <code>TARGETS</code> для
                установки целей, созданных в рамках проекта.
            </p>
            <p>
                Список <em>files...</em>, переданных в <code>FILES</code> или <code>PROGRAMS</code>, может использовать
                "генераторные выражения" с синтаксисом <code>$&lt;...&gt;</code>. См. руководство
                <em>cmake-generator-expressions(7)</em> для получения доступных выражений. Однако, если какой-либо
                элемент начинается с генераторного выражения, оно должно оцениваться в полный путь.
            </p>
            <p>
                Должен быть предоставлен либо <code>TYPE</code>, либо <code>DESTINATION</code>, но не оба. Аргумент
                <code>TYPE</code> указывает тип файла, который устанавливается. Путь назначения будет установлен
                автоматически, используя соответствующую переменную из <code>GNUInstallDirs</code> или используя
                встроенное значение по умолчанию, если эта переменная не определена. См. таблицу ниже для поддерживаемых
                типов файлов и соответствующих переменных и значений по умолчанию. Проекты могут предоставить аргумент
                <code>DESTINATION</code> вместо типа файла, если они хотят явно определить путь установки.
            </p>

            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>TYPE Argument</th>
                        <th>GNUInstallDirs Variable</th>
                        <th>Built-In Default</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>BIN</td>
                        <td>${CMAKE_INSTALL_BINDIR}</td>
                        <td>bin</td>
                    </tr>
                    <tr>
                        <td>SBIN</td>
                        <td>${CMAKE_INSTALL_SBINDIR}</td>
                        <td>sbin</td>
                    </tr>
                    <tr>
                        <td>LIB</td>
                        <td>${CMAKE_INSTALL_LIBDIR}</td>
                        <td>lib</td>
                    </tr>
                    <tr>
                        <td>INCLUDE</td>
                        <td>${CMAKE_INSTALL_INCLUDEDIR}</td>
                        <td>include</td>
                    </tr>
                    <tr>
                        <td>SYSCONF</td>
                        <td>${CMAKE_INSTALL_SYSCONFDIR}</td>
                        <td>etc</td>
                    </tr>
                    <tr>
                        <td>SHAREDSTATE</td>
                        <td>${CMAKE_INSTALL_SHARESTATEDIR}</td>
                        <td>com</td>
                    </tr>
                    <tr>
                        <td>LOCALSTATE</td>
                        <td>${CMAKE_INSTALL_LOCALSTATEDIR}</td>
                        <td>var</td>
                    </tr>
                    <tr>
                        <td>RUNSTATE</td>
                        <td>${CMAKE_INSTALL_RUNSTATEDIR}</td>
                        <td>&lt;LOCALSTATE dir&gt;/run</td>
                    </tr>
                    <tr>
                        <td>DATA</td>
                        <td>${CMAKE_INSTALL_DATADIR}</td>
                        <td>&lt;DATAROOT dir&gt;</td>
                    </tr>
                    <tr>
                        <td>INFO</td>
                        <td>${CMAKE_INSTALL_INFODIR}</td>
                        <td>&lt;DATAROOT dir&gt;/info</td>
                    </tr>
                    <tr>
                        <td>LOCALE</td>
                        <td>${CMAKE_INSTALL_LOCALEDIR}</td>
                        <td>&lt;DATAROOT dir&gt;/locale</td>
                    </tr>
                    <tr>
                        <td>MAN</td>
                        <td>${CMAKE_INSTALL_MANDIR}</td>
                        <td>&lt;DATAROOT dir&gt;/man</td>
                    </tr>
                    <tr>
                        <td>DOC</td>
                        <td>${CMAKE_INSTALL_DOCDIR}</td>
                        <td>&lt;DATAROOT dir&gt;/doc</td>
                    </tr>
                </tbody>
            </table>

            <p>
                Проекты, которые хотят следовать распространенной практике установки заголовков в подкаталог,
                специфичный для проекта, должны указать путь назначения, а не полагаться на указанные выше значения по
                умолчанию. Использование наборов файлов для заголовков вместо <code>install(FILES)</code> было бы еще
                лучше (см. <code>target_sources(FILE_SET)</code>).
            </p>
            <p>
                Обратите внимание, что некоторые из встроенных значений типов используют каталог DATAROOT в качестве
                префикса. Префикс DATAROOT рассчитывается аналогично типам, с переменной
                <code>CMAKE_INSTALL_DATAROOTDIR</code> и значением по умолчанию <code>share</code>. Вы не можете
                использовать DATAROOT в качестве параметра <code>TYPE</code>; пожалуйста, используйте вместо этого
                <code>DATA</code>.
            </p>
            <p>
                Чтобы сделать пакеты соответствующими правилам файловой системы дистрибутива, если проекты должны
                указать DESTINATION, настоятельно рекомендуется использовать путь, начинающийся с соответствующей
                переменной <code>GNUInstallDirs</code>. Это позволяет администраторам пакетов контролировать путь
                установки, устанавливая соответствующие кэш-переменные. Следующий пример показывает, как следовать этому
                совету, устанавливая изображение в подкаталог документации, специфичный для проекта:
            </p>
            <pre><code>
            include(GNUInstallDirs)
            install(FILES logo.png
                    DESTINATION ${CMAKE_INSTALL_DOCDIR}/myproj
            )
            </code></pre>

            <p>
                Новое в версии 3.4: Путь назначения установки, указанный в аргументе <code>DESTINATION</code>, может
                использовать "генераторные выражения" с синтаксисом <code>$&lt;...&gt;</code>. См. руководство
                <em>cmake-generator-expressions(7)</em> для получения доступных выражений.
            </p>
            <p>
                Новое в версии 3.20: Переименование установки, указанное в аргументе <code>RENAME</code>, может
                использовать "генераторные выражения" с синтаксисом <code>$&lt;...&gt;</code>. См. руководство
                <em>cmake-generator-expressions(7)</em> для получения доступных выражений.
            </p>

            <div class="container mt-5">
                <h1 class="mb-4">install(DIRECTORY &lt;dir&gt;... [...])</h1>

                <div class="alert alert-info" role="alert">
                    <strong>Примечание:</strong> Для установки дерева каталогов с заголовочными файлами, рассмотрите
                    возможность использования наборов файлов, определяемых с помощью
                    <code>target_sources(FILE_SET)</code>. Наборы файлов не только сохраняют структуру каталогов, но и
                    связывают заголовочные файлы с целью и устанавливают их как часть этой цели.
                </div>

                <p>Команда <code>install</code> устанавливает содержимое одного или нескольких каталогов:</p>

                <pre><code>install(DIRECTORY dirs...
                TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;
                [FILE_PERMISSIONS &lt;permission&gt;...]
                [DIRECTORY_PERMISSIONS &lt;permission&gt;...]
                [USE_SOURCE_PERMISSIONS] [OPTIONAL] [MESSAGE_NEVER]
                [CONFIGURATIONS &lt;config&gt;...]
                [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL]
                [FILES_MATCHING]
                [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]
                [EXCLUDE] [PERMISSIONS &lt;permission&gt;...]] [...])
                </code></pre>

                <p>Форма команды <code>DIRECTORY</code> копирует содержимое одного или нескольких каталогов в указанный
                    путь назначения. Структура каталогов копируется дословно в место назначения. Последний компонент
                    каждого имени каталога добавляется к каталогу назначения, но можно использовать завершающий слеш,
                    чтобы избежать этого, так как он оставляет последний компонент пустым. Каталоги, указанные как
                    относительные пути, интерпретируются относительно текущего исходного каталога. Если имена входных
                    каталогов не указаны, каталог назначения будет создан, но в него ничего не будет установлено.</p>

                <p>Опции <code>FILE_PERMISSIONS</code> и <code>DIRECTORY_PERMISSIONS</code> задают разрешения для файлов
                    и каталогов в месте назначения. Если указана опция <code>USE_SOURCE_PERMISSIONS</code>, а
                    <code>FILE_PERMISSIONS</code> не указаны, то разрешения файлов будут скопированы из исходной
                    структуры каталогов. Если разрешения не указаны, файлам будут даны разрешения по умолчанию,
                    указанные в форме команды <code>FILES</code>, а каталогам — разрешения по умолчанию, указанные в
                    форме команды <code>PROGRAMS</code>.
                </p>

                <div class="alert alert-info" role="alert">
                    <strong>Новое в версии 3.1:</strong> Опция <code>MESSAGE_NEVER</code> отключает вывод статуса
                    установки файлов.
                </div>

                <p>Установка каталогов может быть детализирована с использованием опций <code>PATTERN</code> или
                    <code>REGEX</code>. Эти опции "соответствия" задают шаблон глобирования или регулярное выражение для
                    сопоставления с каталогами или файлами, найденными внутри входных каталогов. Они могут
                    использоваться для применения определенных опций к подмножеству файлов и каталогов.
                </p>

                <p>По умолчанию все файлы и каталоги устанавливаются, независимо от того, совпадают ли они с шаблоном.
                    Опция <code>FILES_MATCHING</code> может быть указана до первой опции соответствия, чтобы отключить
                    установку файлов (но не каталогов), не соответствующих ни одному выражению.</p>

                <div class="alert alert-secondary">
                    <strong>Пример:</strong> следующий код устанавливает изображения из исходного дерева:
                    <pre><code>install(DIRECTORY src/ DESTINATION doc/myproj
                FILES_MATCHING PATTERN "*.png")
                    </code></pre>
                </div>

                <p>Некоторые опции могут следовать за выражением <code>PATTERN</code> или <code>REGEX</code>, как
                    описано в <code>string(REGEX)</code>, и применяются только к файлам или каталогам, соответствующим
                    им. Опция <code>EXCLUDE</code> пропустит совпадающий файл или каталог. Опция
                    <code>PERMISSIONS</code> переопределяет настройку разрешений для совпадающего файла или каталога.
                </p>

                <div class="alert alert-secondary">
                    <strong>Пример:</strong> следующий код устанавливает каталоги <code>icons</code> и
                    <code>scripts</code> с определенными разрешениями и исключением каталогов <code>CVS</code>:
                    <pre><code>install(DIRECTORY icons scripts/ DESTINATION share/myproj
                PATTERN "CVS" EXCLUDE
                PATTERN "scripts/*"
                PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ
                            GROUP_EXECUTE GROUP_READ)
                    </code></pre>
                </div>

                <p>Либо <code>TYPE</code>, либо <code>DESTINATION</code> должны быть указаны, но не оба сразу. Аргумент
                    <code>TYPE</code> задает общий тип файла для файлов внутри перечисленных каталогов, которые
                    устанавливаются. Путь назначения будет автоматически установлен с использованием соответствующей
                    переменной из <code>GNUInstallDirs</code>, или будет использоваться встроенный по умолчанию, если
                    эта переменная не определена.
                </p>

                <table class="table table-bordered mt-4">
                    <thead class="table-dark">
                        <tr>
                            <th>Тип (TYPE)</th>
                            <th>Переменная GNUInstallDirs</th>
                            <th>Встроенное значение по умолчанию</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>BIN</td>
                            <td>${CMAKE_INSTALL_BINDIR}</td>
                            <td>bin</td>
                        </tr>
                        <tr>
                            <td>SBIN</td>
                            <td>${CMAKE_INSTALL_SBINDIR}</td>
                            <td>sbin</td>
                        </tr>
                        <tr>
                            <td>LIB</td>
                            <td>${CMAKE_INSTALL_LIBDIR}</td>
                            <td>lib</td>
                        </tr>
                        <tr>
                            <td>INCLUDE</td>
                            <td>${CMAKE_INSTALL_INCLUDEDIR}</td>
                            <td>include</td>
                        </tr>
                        <tr>
                            <td>SYSCONF</td>
                            <td>${CMAKE_INSTALL_SYSCONFDIR}</td>
                            <td>etc</td>
                        </tr>
                        <tr>
                            <td>SHAREDSTATE</td>
                            <td>${CMAKE_INSTALL_SHARESTATEDIR}</td>
                            <td>com</td>
                        </tr>
                        <tr>
                            <td>LOCALSTATE</td>
                            <td>${CMAKE_INSTALL_LOCALSTATEDIR}</td>
                            <td>var</td>
                        </tr>
                        <tr>
                            <td>RUNSTATE</td>
                            <td>${CMAKE_INSTALL_RUNSTATEDIR}</td>
                            <td>&lt;LOCALSTATE dir&gt;/run</td>
                        </tr>
                        <tr>
                            <td>DATA</td>
                            <td>${CMAKE_INSTALL_DATADIR}</td>
                            <td>&lt;DATAROOT dir&gt;</td>
                        </tr>
                        <tr>
                            <td>INFO</td>
                            <td>${CMAKE_INSTALL_INFODIR}</td>
                            <td>&lt;DATAROOT dir&gt;/info</td>
                        </tr>
                        <tr>
                            <td>LOCALE</td>
                            <td>${CMAKE_INSTALL_LOCALEDIR}</td>
                            <td>&lt;DATAROOT dir&gt;/locale</td>
                        </tr>
                        <tr>
                            <td>MAN</td>
                            <td>${CMAKE_INSTALL_MANDIR}</td>
                            <td>&lt;DATAROOT dir&gt;/man</td>
                        </tr>
                        <tr>
                            <td>DOC</td>
                            <td>${CMAKE_INSTALL_DOCDIR}</td>
                            <td>&lt;DATAROOT dir&gt;/doc</td>
                        </tr>
                    </tbody>
                </table>

                <p>Обратите внимание, что некоторые значения по умолчанию для типов файлов используют каталог
                    <code>DATAROOT</code> в качестве префикса. Префикс <code>DATAROOT</code> рассчитывается аналогично
                    типам файлов, с переменной <code>CMAKE_INSTALL_DATAROOTDIR</code>, и значением по умолчанию
                    <code>share</code>. Вы не можете использовать <code>DATAROOT</code> в качестве параметра
                    <code>TYPE</code>; пожалуйста, используйте <code>DATA</code> вместо этого.
                </p>

                <p>Для того чтобы пакеты соответствовали правилам файловой структуры дистрибутивов, если проектам
                    необходимо указать <code>DESTINATION</code>, настоятельно рекомендуется использовать путь,
                    начинающийся с соответствующей переменной из <code>GNUInstallDirs</code>. Это позволяет мейнтейнерам
                    пакетов контролировать место установки, задавая соответствующие переменные кэша.</p>

                <p><strong>Новое в версии 3.4:</strong> Путь установки, указанный в аргументе <code>DESTINATION</code>,
                    может использовать "генераторные выражения" с синтаксисом <code>$&lt;...&gt;</code>. См. руководство
                    по <a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html"
                        target="_blank">cmake-generator-expressions(7)</a> для доступных выражений.</p>

                <p><strong>Новое в версии 3.5:</strong> Список директорий <code>dirs...</code>, переданный в
                    <code>DIRECTORY</code>, также может использовать "генераторные выражения".
                </p>

                <h4>Установка CMake скриптов или кода</h4>
                <p>Вызов CMake скриптов или кода во время установки:</p>
                <pre>
    <code>install([[SCRIPT &lt;file&gt;] [CODE &lt;code&gt;]]
            [ALL_COMPONENTS | COMPONENT &lt;component&gt;]
            [EXCLUDE_FROM_ALL] [...])</code>
    </pre>
                <p>Форма <code>SCRIPT</code> вызовет указанные файлы CMake скриптов во время установки. Если имя файла
                    скрипта является относительным путем, оно будет интерпретировано относительно текущего каталога
                    исходников. Форма <code>CODE</code> выполнит указанный код CMake во время установки. Код указывается
                    в виде одного аргумента внутри строки в двойных кавычках. Например, код</p>
                <pre>
    <code>install(CODE "MESSAGE(&quot;Пример сообщения установки.&quot;)")</code>
    </pre>
                <p>выведет сообщение во время установки.</p>

                <p><strong>Новое в версии 3.21:</strong> При использовании опции <code>ALL_COMPONENTS</code>
                    пользовательский код установки будет выполняться для каждого компонента компонентной установки. Эта
                    опция взаимоисключающая с опцией <code>COMPONENT</code>.</p>

                <p><strong>Новое в версии 3.14:</strong> <code>&lt;file&gt;</code> или <code>&lt;code&gt;</code> могут
                    использовать "генераторные выражения" с синтаксисом <code>$&lt;...&gt;</code> (в случае
                    <code>&lt;file&gt;</code> это относится к использованию в имени файла, а не в содержимом файла). См.
                    руководство по <a
                        href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html"
                        target="_blank">cmake-generator-expressions(7)</a> для доступных выражений.
                </p>

                <h4>Установка CMake файла для экспорта целей</h4>
                <p>Установка CMake файла для экспорта целей для зависимых проектов:</p>
                <pre>
    <code>install(EXPORT &lt;export-name&gt; DESTINATION &lt;dir&gt;
            [NAMESPACE &lt;namespace&gt;] [FILE &lt;name&gt;.cmake]
            [PERMISSIONS &lt;permission&gt;...]
            [CONFIGURATIONS &lt;config&gt;...]
            [CXX_MODULES_DIRECTORY &lt;directory&gt;]
            [EXPORT_LINK_INTERFACE_LIBRARIES]
            [COMPONENT &lt;component&gt;]
            [EXCLUDE_FROM_ALL]
            [EXPORT_PACKAGE_DEPENDENCIES])</code>
    </pre>
                <pre>
    <code>install(EXPORT_ANDROID_MK &lt;export-name&gt; DESTINATION &lt;dir&gt; [...])</code>
    </pre>
                <p>Форма <code>EXPORT</code> генерирует и устанавливает CMake файл, содержащий код для импорта целей из
                    установленного дерева в другой проект. Установленные цели ассоциируются с экспортом
                    <code>&lt;export-name&gt;</code> с помощью опции <code>EXPORT</code> в
                    <code>install(TARGETS)</code>. Опция <code>NAMESPACE</code> добавит префикс
                    <code>&lt;namespace&gt;</code> к именам целей в импортируемом файле. По умолчанию сгенерированный
                    файл будет называться <code>&lt;export-name&gt;.cmake</code>, но можно использовать опцию
                    <code>FILE</code> для указания другого имени. Значение, переданное в <code>FILE</code>, должно быть
                    именем файла с расширением <code>.cmake</code>. Если указана опция <code>CONFIGURATIONS</code>, файл
                    будет установлен только при установке одной из указанных конфигураций. Дополнительно,
                    сгенерированный файл импорта будет ссылаться только на соответствующие конфигурации целей. См.
                    переменную <code>CMAKE_MAP_IMPORTED_CONFIG_&lt;CONFIG&gt;</code> для отображения конфигураций
                    зависимых проектов в установленные конфигурации. Ключевое слово
                    <code>EXPORT_LINK_INTERFACE_LIBRARIES</code>, если присутствует, вызывает экспорт содержимого
                    свойств, соответствующих (IMPORTED_)?LINK_INTERFACE_LIBRARIES(_&lt;CONFIG&gt;)?.
                </p>

                <div class="alert alert-warning">
                    <strong>Примечание:</strong> Установленный файл <code>&lt;export-name&gt;.cmake</code> может
                    сопровождаться дополнительными файлами <code>&lt;export-name&gt;-*.cmake</code> для каждой
                    конфигурации, которые будут загружены с помощью globbing. Не используйте имя экспорта, совпадающее с
                    именем пакета в сочетании с установкой файла <code>&lt;package-name&gt;-config.cmake</code>, иначе
                    последний может быть неправильно выбран globbing и загружен.
                </div>

                <p>При указании опции <code>COMPONENT</code>, указанный <code>&lt;component&gt;</code> неявно зависит от
                    всех компонентов, упомянутых в наборе экспорта. Экспортируемый файл <code>&lt;name&gt;.cmake</code>
                    потребует наличия каждого из экспортируемых компонентов для правильной сборки зависимых проектов.
                    Например, проект может определить компоненты <code>Runtime</code> и <code>Development</code>, с
                    общими библиотеками в компоненте <code>Runtime</code> и статическими библиотеками и заголовками в
                    <code>Development</code>. Набор экспорта также обычно является частью компонента
                    <code>Development</code>, но экспортирует цели из обоих компонентов <code>Runtime</code> и
                    <code>Development</code>. Таким образом, компонент <code>Runtime</code> должен быть установлен, если
                    установлен компонент <code>Development</code>, но не наоборот. Если компонент
                    <code>Development</code> будет установлен без <code>Runtime</code>, зависимые проекты, которые
                    попытаются связаться с ним, столкнутся с ошибками сборки. Менеджеры пакетов, такие как APT и RPM,
                    обычно решают это путем указания компонента <code>Runtime</code> в качестве зависимости компонента
                    <code>Development</code> в метаданных пакета, гарантируя, что библиотека всегда установлена, если
                    присутствуют заголовки и файл экспорта CMake.
                </p>

                <p><strong>Новое в версии 3.7:</strong> В дополнение к языковым файлам CMake, режим
                    <code>EXPORT_ANDROID_MK</code> может использоваться для указания экспорта в систему сборки Android
                    NDK. Этот режим принимает те же параметры, что и обычный режим экспорта. Android NDK поддерживает
                    использование предварительно собранных библиотек, как статических, так и общих. Это позволяет CMake
                    собрать библиотеки проекта и сделать их доступными для системы сборки NDK с учетом транзитивных
                    зависимостей, флагов включения и определений, необходимых для использования библиотек.
                </p>

                <h4>Директория CXX_MODULES_DIRECTORY</h4>
                <p><strong>Новое в версии 3.28:</strong></p>
                <p>Укажите поддиректорию для хранения информации о модулях C++ для целей в наборе экспорта. Эта
                    директория будет заполнена файлами, добавляющими необходимую информацию о свойствах целей к
                    соответствующим целям. Обратите внимание, что без этой информации ни один из модулей C++, являющихся
                    частью целей в наборе экспорта, не поддерживает импорт в целевых проектах.</p>

                <h4>Зависимости пакетов экспорта</h4>
                <div class="alert alert-warning">
                    <strong>Примечание:</strong> Экспериментально. Включается с помощью
                    <code>CMAKE_EXPERIMENTAL_EXPORT_PACKAGE_DEPENDENCIES</code>.
                </div>
                <p>Укажите, что вызовы <code>find_dependency()</code> должны быть экспортированы. Если этот аргумент
                    указан, CMake анализирует все цели в наборе экспорта и собирает их интерфейсные зависимости. Если
                    такие цели были найдены с помощью <code>find_package()</code> или имеют установленное свойство
                    <code>EXPORT_FIND_PACKAGE_NAME</code>, и такая зависимость пакета не была отключена путем передачи
                    <code>ENABLED OFF</code> в <code>export(SETUP)</code>, то будет записан вызов
                    <code>find_dependency()</code> с соответствующим именем пакета, аргументом <code>REQUIRED</code> и
                    любыми дополнительными аргументами, указанными аргументом <code>EXTRA_ARGS</code> в
                    <code>export(SETUP)</code>. Любые зависимости пакетов, указанные вручную путем передачи
                    <code>ENABLED ON</code> в <code>export(SETUP)</code>, также добавляются, даже если экспортируемые
                    цели не зависят от каких-либо целей из них.
                </p>
                <p>Вызовы <code>find_dependency()</code> записываются в следующем порядке:</p>
                <ul>
                    <li>Любые зависимости пакетов, указанные в <code>export(SETUP)</code>, записываются в порядке, в
                        котором они были впервые указаны, независимо от того, содержат ли они интерфейсные зависимости
                        экспортируемых целей.</li>
                    <li>Любые зависимости пакетов, содержащие интерфейсные зависимости экспортируемых целей и никогда не
                        указанные в <code>export(SETUP)</code>, записываются в порядке, в котором они были впервые
                        найдены.</li>
                </ul>

                <p>Форма <code>EXPORT</code> полезна для того, чтобы помочь внешним проектам использовать цели,
                    собранные и установленные текущим проектом. Например, следующий код</p>
                <pre>
    <code>install(TARGETS myexe EXPORT myproj DESTINATION bin)
    install(EXPORT myproj NAMESPACE mp_ DESTINATION lib/myproj)
    install(EXPORT_ANDROID_MK myproj DESTINATION share/ndk-modules)</code>
    </pre>
                <p>установит исполняемый файл <code>myexe</code> в <code>&lt;prefix&gt;/bin</code> и код для его импорта
                    в файл <code>&lt;prefix&gt;/lib/myproj/myproj.cmake</code> и
                    <code>&lt;prefix&gt;/share/ndk-modules/Android.mk</code>. Внешний проект может загрузить этот файл с
                    помощью команды <code>include</code> и ссылаться на исполняемый файл <code>myexe</code> из
                    установленного дерева, используя импортированное имя цели <code>mp_myexe</code>, как если бы цель
                    была построена в его собственном дереве.
                </p>
                <h4>Установка набора зависимостей во время выполнения</h4>
                <p><strong>Новое в версии 3.21.</strong></p>
                <p>Устанавливает набор зависимостей во время выполнения:</p>
                <pre>
                    <code>install(RUNTIME_DEPENDENCY_SET &lt;set-name&gt;
                        [[LIBRARY|RUNTIME|FRAMEWORK]
                         [DESTINATION &lt;dir&gt;]
                         [PERMISSIONS &lt;permission&gt;...]
                         [CONFIGURATIONS &lt;config&gt;...]
                         [COMPONENT &lt;component&gt;]
                         [NAMELINK_COMPONENT &lt;component&gt;]
                         [OPTIONAL] [EXCLUDE_FROM_ALL]
                        ] [...]
                        [PRE_INCLUDE_REGEXES &lt;regex&gt;...]
                        [PRE_EXCLUDE_REGEXES &lt;regex&gt;...]
                        [POST_INCLUDE_REGEXES &lt;regex&gt;...]
                        [POST_EXCLUDE_REGEXES &lt;regex&gt;...]
                        [POST_INCLUDE_FILES &lt;file&gt;...]
                        [POST_EXCLUDE_FILES &lt;file&gt;...]
                        [DIRECTORIES &lt;dir&gt;...]
                        )</code>
                    </pre>
                <p>Устанавливает набор зависимостей во время выполнения, ранее созданный одной или несколькими командами
                    <code>install(TARGETS)</code> или <code>install(IMPORTED_RUNTIME_ARTIFACTS)</code>. Зависимости
                    целей, принадлежащих к набору зависимостей во время выполнения, устанавливаются в назначении
                    <code>RUNTIME</code> и компоненте на платформах с динамическими библиотеками (DLL), и в назначении
                    <code>LIBRARY</code> и компоненте на платформах без динамических библиотек (non-DLL). В macOS
                    фреймворки устанавливаются в назначении <code>FRAMEWORK</code> и компоненте. Цели, построенные
                    внутри дерева сборки, никогда не будут установлены как зависимости во время выполнения, равно как и
                    их собственные зависимости, если сами цели не установлены с помощью <code>install(TARGETS)</code>.
                </p>

                <p>Сгенерированный скрипт установки вызывает команду <code>file(GET_RUNTIME_DEPENDENCIES)</code> на
                    файлах дерева сборки для вычисления зависимостей во время выполнения. Исполняемые файлы дерева
                    сборки передаются в качестве аргумента <code>EXECUTABLES</code>, общие библиотеки дерева сборки — в
                    качестве аргумента <code>LIBRARIES</code>, а модули дерева сборки — в качестве аргумента
                    <code>MODULES</code>. В macOS, если одно из исполняемых файлов является <code>MACOSX_BUNDLE</code>,
                    это исполняемое файл передается в качестве аргумента <code>BUNDLE_EXECUTABLE</code>. В наборе
                    зависимостей во время выполнения на macOS может быть не более одного такого бандла. Свойство
                    <code>MACOSX_BUNDLE</code> не влияет на другие платформы. Обратите внимание, что команда
                    <code>file(GET_RUNTIME_DEPENDENCIES)</code> поддерживает сбор только зависимостей во время
                    выполнения для платформ Windows, Linux и macOS, поэтому <code>install(RUNTIME_DEPENDENCY_SET)</code>
                    имеет те же ограничения.</p>

                <p>Следующие подаргументы передаются как соответствующие аргументы в команду
                    <code>file(GET_RUNTIME_DEPENDENCIES)</code> (для тех, кто предоставляет непустой список директорий,
                    регулярных выражений или файлов). Все они поддерживают генераторные выражения:</p>
                <ul>
                    <li><code>DIRECTORIES &lt;dir&gt;...</code></li>
                    <li><code>PRE_INCLUDE_REGEXES &lt;regex&gt;...</code></li>
                    <li><code>PRE_EXCLUDE_REGEXES &lt;regex&gt;...</code></li>
                    <li><code>POST_INCLUDE_REGEXES &lt;regex&gt;...</code></li>
                    <li><code>POST_EXCLUDE_REGEXES &lt;regex&gt;...</code></li>
                    <li><code>POST_INCLUDE_FILES &lt;file&gt;...</code></li>
                    <li><code>POST_EXCLUDE_FILES &lt;file&gt;...</code></li>
                </ul>

                <div class="alert alert-warning">
                    <strong>Примечание:</strong> Эта команда заменяет команду <code>install_targets()</code> и свойства
                    цели <code>PRE_INSTALL_SCRIPT</code> и <code>POST_INSTALL_SCRIPT</code>. Она также заменяет формы
                    <code>FILES</code> в командах <code>install_files()</code> и <code>install_programs()</code>.
                    Порядок обработки этих правил установки относительно тех, которые генерируются командами
                    <code>install_targets()</code>, <code>install_files()</code> и <code>install_programs()</code>, не
                    определен.
                </div>

                <h5>Пример: Установка целей с компонентами для каждого артефакта</h5>
                <p>Рассмотрим проект, который определяет цели с разными типами артефактов:</p>
                <pre>
                    <code>add_executable(myExe myExe.c)
                add_library(myStaticLib STATIC myStaticLib.c)
                target_sources(myStaticLib PUBLIC FILE_SET HEADERS FILES myStaticLib.h)
                add_library(mySharedLib SHARED mySharedLib.c)
                target_sources(mySharedLib PUBLIC FILE_SET HEADERS FILES mySharedLib.h)
                set_property(TARGET mySharedLib PROPERTY SOVERSION 1)</code>
                    </pre>
                <p>Мы можем вызвать <code>install(TARGETS)</code> с аргументами <code>&lt;artifact-kind&gt;</code> для
                    указания различных опций для каждого типа артефакта:</p>
                <pre>
                    <code>install(TARGETS
                          myExe
                          mySharedLib
                          myStaticLib
                        RUNTIME           # Следующие опции применяются к артефактам времени выполнения.
                          COMPONENT Runtime
                        LIBRARY           # Следующие опции применяются к библиотечным артефактам.
                          COMPONENT Runtime
                          NAMELINK_COMPONENT Development
                        ARCHIVE           # Следующие опции применяются к архивным артефактам.
                          COMPONENT Development
                          DESTINATION lib/static
                        FILE_SET HEADERS  # Следующие опции применяются к набору файлов HEADERS.
                          COMPONENT Development
                        )</code>
                    </pre>
                <p>Это выполнит следующие действия:</p>
                <ul>
                    <li>Установит <code>myExe</code> в <code>&lt;prefix&gt;/bin</code>, что является назначением по
                        умолчанию для артефактов <code>RUNTIME</code>, как часть компонента <code>Runtime</code>.</li>
                    <li>На платформах без динамических библиотек (non-DLL):</li>
                    <ul>
                        <li>Установит <code>libmySharedLib.so.1</code> в <code>&lt;prefix&gt;/lib</code>, что является
                            назначением по умолчанию для артефактов <code>LIBRARY</code>, как часть компонента
                            <code>Runtime</code>.</li>
                        <li>Установит символьную ссылку "namelink" <code>libmySharedLib.so</code> в
                            <code>&lt;prefix&gt;/lib</code>, как часть компонента <code>Development</code>.</li>
                    </ul>
                    <li>На платформах с динамическими библиотеками (DLL):</li>
                    <ul>
                        <li>Установит <code>mySharedLib.dll</code> в <code>&lt;prefix&gt;/bin</code>, как часть
                            компонента <code>Runtime</code>.</li>
                        <li>Установит <code>mySharedLib.lib</code> в <code>&lt;prefix&gt;/lib/static</code>, как часть
                            компонента <code>Development</code>.</li>
                    </ul>
                    <li>Установит <code>myStaticLib</code> в <code>&lt;prefix&gt;/lib/static</code>, как часть
                        компонента <code>Development</code>.</li>
                    <li>Установит <code>mySharedLib.h</code> и <code>myStaticLib.h</code> в
                        <code>&lt;prefix&gt;/include</code>, что является назначением по умолчанию для набора файлов
                        типа <code>HEADERS</code>, как часть компонента <code>Development</code>.</li>
                </ul>

                <h5>Пример: Установка целей в назначения для каждой конфигурации</h5>
                <p>Каждый вызов <code>install(TARGETS)</code> устанавливает указанный выходной артефакт цели в не более
                    чем одно назначение, но само правило установки может быть отфильтровано с помощью опции
                    <code>CONFIGURATIONS</code>. Чтобы установить в другое назначение для каждой конфигурации, требуется
                    по одному вызову на каждую конфигурацию. Например, следующий код:</p>
                <pre>
                    <code>install(TARGETS myExe
                        CONFIGURATIONS Debug
                        RUNTIME
                          DESTINATION Debug/bin
                        )
                install(TARGETS myExe
                        CONFIGURATIONS Release
                        RUNTIME
                          DESTINATION Release/bin
                        )</code>
                    </pre>
                <p>установит <code>myExe</code> в <code>&lt;prefix&gt;/Debug/bin</code> для конфигурации
                    <code>Debug</code> и в <code>&lt;prefix&gt;/Release/bin</code> для конфигурации
                    <code>Release</code>.</p>

                <h5>Сгенерированный скрипт установки</h5>
                <div class="alert alert-warning">
                    <strong>Примечание:</strong> Использование этой функции не рекомендуется. Пожалуйста, рассмотрите
                    возможность использования <code>cmake --install</code> вместо этого.
                </div>
                <p>Команда <code>install()</code> генерирует файл <code>cmake_install.cmake</code> внутри каталога
                    сборки, который используется внутренне сгенерированной целью установки и <code>CPack</code>. Вы
                    также можете вызвать этот скрипт вручную с помощью <code>cmake -P</code>. Этот скрипт принимает
                    несколько переменных:</p>
                <ul>
                    <li><strong>COMPONENT</strong>: Установите эту переменную, чтобы установить только один компонент
                        <code>CPack</code> вместо всех них. Например, если вы хотите установить только компонент
                        <code>Development</code>, выполните
                        <code>cmake -DCOMPONENT=Development -P cmake_install.cmake</code>.</li>
                    <li><strong>BUILD_TYPE</strong>: Установите эту переменную, чтобы изменить тип сборки, если вы
                        используете генератор с поддержкой нескольких конфигураций. Например, чтобы установить с
                        конфигурацией <code>Debug</code>, выполните
                        <code>cmake -DBUILD_TYPE=Debug -P cmake_install.cmake</code>.</li>
                    <li><strong>DESTDIR</strong>: Это переменная окружения, а не переменная <code>CMake</code>. Она
                        позволяет изменить префикс установки на UNIX-системах. См. <code>DESTDIR</code> для деталей.
                    </li>
                </ul>

            </div>
        </div>
</body>

</html>