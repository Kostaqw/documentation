<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>if</title>
    <link href="../lib/bootstrap.min.css" rel="stylesheet">
    <link href="../css/styles.css" rel="stylesheet">
    <script src="../js/jquery-3.5.1.min.js"></script>
    <script src="../js/popper.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <script src="../js/scripts.js"></script>
</head>

<body>
    <div class="container">
        <div id="if_command" class="mt-4">
            <h2>if</h2>
            <p>Условное выполнение группы команд.</p>
            <h3>Синопсис</h3>
            <pre><code>if(&lt;condition&gt;)
          &lt;commands&gt;
        elseif(&lt;condition&gt;) # необязательный блок, можно повторять
          &lt;commands&gt;
        else()              # необязательный блок
          &lt;commands&gt;
        endif()</code></pre>
            <p>Условие в аргументе <code>if</code> оценивается согласно синтаксису условий, описанному ниже. Если результат истинный, выполняются команды в блоке <code>if</code>. В противном случае, опциональные блоки <code>elseif</code> обрабатываются таким же образом. Наконец, если ни одно условие не истинно, выполняются команды в опциональном блоке <code>else</code>.</p>
            <p>Для совместимости с предыдущими версиями команды <code>else()</code> и <code>endif()</code> допускают необязательный аргумент <code>&lt;condition&gt;</code>. Если он используется, он должен быть дословным повтором аргумента команды <code>if</code>.</p>
            <h3>Синтаксис условий</h3>
            <p>Следующий синтаксис применяется к аргументу <code>condition</code> в выражениях <code>if</code>, <code>elseif</code> и <code>while()</code>.</p>
            <h4>Составные условия оцениваются в следующем порядке приоритетов:</h4>
            <ul>
                <li>Скобки.</li>
                <li>Унарные проверки, такие как <code>EXISTS</code>, <code>COMMAND</code> и <code>DEFINED</code>.</li>
                <li>Бинарные проверки, такие как <code>EQUAL</code>, <code>LESS</code>, <code>LESS_EQUAL</code>, <code>GREATER</code>, <code>GREATER_EQUAL</code>, <code>STREQUAL</code>, <code>STRLESS</code>, <code>STRLESS_EQUAL</code>, <code>STRGREATER</code>, <code>STRGREATER_EQUAL</code>, <code>VERSION_EQUAL</code>, <code>VERSION_LESS</code>, <code>VERSION_LESS_EQUAL</code>, <code>VERSION_GREATER</code>, <code>VERSION_GREATER_EQUAL</code>, <code>PATH_EQUAL</code> и <code>MATCHES</code>.</li>
                <li>Унарный логический оператор <code>NOT</code>.</li>
                <li>Бинарные логические операторы <code>AND</code> и <code>OR</code>, слева направо, без короткого замыкания.</li>
            </ul>
            <h4>Основные выражения</h4>
            <pre><code>if(&lt;constant&gt;)</code></pre>
            <p>Истинно, если константа равна 1, <code>ON</code>, <code>YES</code>, <code>TRUE</code>, <code>Y</code> или ненулевому числу (включая числа с плавающей запятой). Ложно, если константа равна 0, <code>OFF</code>, <code>NO</code>, <code>FALSE</code>, <code>N</code>, <code>IGNORE</code>, <code>NOTFOUND</code>, пустой строке или заканчивается суффиксом <code>-NOTFOUND</code>. Именованные булевы константы регистронезависимы. Если аргумент не является одной из этих конкретных констант, он трактуется как переменная или строка (см. раздел "Расширение переменных" ниже), и применяются одна из следующих двух форм.</p>
            <pre><code>if(&lt;variable&gt;)</code></pre>
            <p>Истинно, если дана переменная, которая определена и имеет значение, не являющееся ложной константой. В противном случае — ложно, включая случаи, когда переменная не определена. Обратите внимание, что аргументы макросов не являются переменными. Переменные окружения также не могут быть проверены таким образом, например, <code>if(ENV{some_var})</code> всегда оценивается как ложное.</p>
            <pre><code>if(&lt;string&gt;)</code></pre>
            <p>Заключенная в кавычки строка всегда оценивается как ложная, если только:</p>
            <ul>
                <li>Значение строки является одной из истинных констант, или</li>
                <li>Политика <code>CMP0054</code> не установлена в значение <code>NEW</code>, и значение строки совпадает с именем переменной, на которое влияет поведение <code>CMP0054</code>.</li>
            </ul>
            <h4>Логические операторы</h4>
            <pre><code>if(NOT &lt;condition&gt;)</code></pre>
            <p>Истинно, если условие ложно.</p>
            <pre><code>if(&lt;cond1&gt; AND &lt;cond2&gt;)</code></pre>
            <p>Истинно, если оба условия будут считаться истинными по отдельности.</p>
            <pre><code>if(&lt;cond1&gt; OR &lt;cond2&gt;)</code></pre>
            <p>Истинно, если любое из условий будет считаться истинным по отдельности.</p>
            <pre><code>if((condition) AND (condition OR (condition)))</code></pre>
            <p>Условия внутри скобок оцениваются первыми, затем оцениваются оставшиеся условия, как в других примерах. Если есть вложенные скобки, то внутренние оцениваются как часть оценки содержащего их условия.</p>
            <h4>Проверки существования</h4>
            <pre><code>if(COMMAND &lt;command-name&gt;)</code></pre>
            <p>Истинно, если данное имя является командой, макросом или функцией, которую можно вызвать.</p>
            <pre><code>if(POLICY &lt;policy-id&gt;)</code></pre>
            <p>Истинно, если данное имя является существующей политикой (формата <code>CMP&lt;NNNN&gt;</code>).</p>
            <pre><code>if(TARGET &lt;target-name&gt;)</code></pre>
            <p>Истинно, если данное имя является существующим логическим именем цели, созданным вызовом команды <code>add_executable()</code>, <code>add_library()</code> или <code>add_custom_target()</code>, которые уже были вызваны (в любом каталоге).</p>
            <pre><code>if(TEST &lt;test-name&gt;)</code></pre>
            <p><strong>Новое в версии 3.3.</strong></p>
            <p>Истинно, если данное имя является существующим именем теста, созданным командой <code>add_test()</code>.</p>
            <pre><code>if(DEFINED &lt;name&gt;|CACHE{&lt;name&gt;}|ENV{&lt;name&gt;})</code></pre>
            <p>Истинно, если переменная, кеш-переменная или переменная окружения с данным именем определена. Значение переменной не имеет значения. Обратите внимание на следующие оговорки:</p>
            <ul>
                <li>Аргументы макросов не являются переменными.</li>
                <li>Невозможно проверить напрямую, является ли <code>&lt;name&gt;</code> не-кеш-переменной. Выражение <code>if(DEFINED someName)</code> будет оцениваться как истинное, если существует либо кеш-переменная, либо не-кеш-переменная <code>someName</code>. В сравнении, выражение <code>if(DEFINED CACHE{someName})</code> будет истинным только в том случае, если существует кеш-переменная <code>someName</code>. Оба выражения нужно проверять, если необходимо знать, существует ли не-кеш-переменная: <code>if(DEFINED someName AND NOT DEFINED CACHE{someName})</code>.</li>
                <li><strong>Новое в версии 3.14:</strong> добавлена поддержка кеш-переменных <code>CACHE{&lt;name&gt;}</code>.</li>
            </ul>
            <pre><code>if(&lt;variable|string&gt; IN_LIST &lt;variable&gt;)</code></pre>
            <p><strong>Новое в версии 3.3.</strong></p>
            <p>Истинно, если данный элемент содержится в именованной списковой переменной.</p>
            <h4>Операции с файлами</h4>
            <pre><code>if(EXISTS &lt;path-to-file-or-directory&gt;)</code></pre>
            <p>Истинно, если указанный файл или каталог существует и доступен для чтения. Поведение определено только для явных полных путей (ведущий <code>~/</code> не интерпретируется как домашний каталог и считается относительным путем). Символические ссылки разрешаются, то есть, если указанный файл или каталог является символической ссылкой, возвращается истина, если целевой объект символической ссылки существует.</p>
            <p>Ложно, если данный путь является пустой строкой.</p>
            <p><strong>Примечание:</strong> предпочитайте <code>if(IS_READABLE)</code> для проверки доступности файла. В будущем <code>if(EXISTS)</code> может быть изменен, чтобы проверять только существование файла.</p>
            <pre><code>if(IS_READABLE &lt;path-to-file-or-directory&gt;)</code></pre>
            <p><strong>Новое в версии 3.29.</strong></p>
            <p>Истинно, если указанный файл или каталог доступен для чтения. Поведение определено только для явных полных путей (ведущий <code>~/</code> не интерпретируется как домашний каталог и считается относительным путем). Символические ссылки разрешаются, то есть, если указанный файл или каталог является символической ссылкой, возвращается истина, если целевой объект символической ссылки доступен для чтения.</p>
            <p>Ложно, если данный путь является пустой строкой.</p>
            <pre><code>if(IS_WRITABLE &lt;path-to-file-or-directory&gt;)</code></pre>
            <p><strong>Новое в версии 3.29.</strong></p>
            <p>Истинно, если указанный файл или каталог доступен для записи. Поведение определено только для явных полных путей (ведущий <code>~/</code> не интерпретируется как домашний каталог и считается относительным путем). Символические ссылки разрешаются, то есть, если указанный файл или каталог является символической ссылкой, возвращается истина, если целевой объект символической ссылки доступен для записи.</p>
            <p>Ложно, если данный путь является пустой строкой.</p>
            <pre><code>if(IS_EXECUTABLE &lt;path-to-file-or-directory&gt;)</code></pre>
            <p><strong>Новое в версии 3.29.</strong></p>
            <p>Истинно, если указанный файл или каталог является исполняемым. Поведение определено только для явных полных путей (ведущий <code>~/</code> не интерпретируется как домашний каталог и считается относительным путем). Символические ссылки разрешаются, то есть, если указанный файл или каталог является символической ссылкой, возвращается истина, если целевой объект символической ссылки является исполняемым.</p>
            <p>Ложно, если данный путь является пустой строкой.</p>
            <pre><code>if(&lt;file1&gt; IS_NEWER_THAN &lt;file2&gt;)</code></pre>
            <p>Истинно, если <code>file1</code> новее <code>file2</code> или если один из двух файлов не существует. Поведение определено только для полных путей. Если временные метки файлов совпадают, сравнение <code>IS_NEWER_THAN</code> возвращает истину, чтобы любые зависимые операции сборки происходили в случае равенства. Это включает случай передачи одного и того же имени файла для обоих <code>file1</code> и <code>file2</code>.</p>
            <pre><code>if(IS_DIRECTORY &lt;path&gt;)</code></pre>
            <p>Истинно, если <code>path</code> является каталогом. Поведение определено только для полных путей.</p>
            <p>Ложно, если данный путь является пустой строкой.</p>
            <pre><code>if(IS_SYMLINK &lt;path&gt;)</code></pre>
            <p>Истинно, если данный путь является символической ссылкой. Поведение определено только для полных путей.</p>
            <pre><code>if(IS_ABSOLUTE &lt;path&gt;)</code></pre>
            <p>Истинно, если данный путь является абсолютным путем. Обратите внимание на следующие особые случаи:</p>
            <ul>
                <li>Пустой путь оценивается как ложный.</li>
                <li>На хостах Windows любой путь, который начинается с буквы диска и двоеточия (например, <code>C:</code>), прямой или обратной косой черты будет оцениваться как истинный. Это означает, что путь типа <code>C:no\base\dir</code> будет оцениваться как истинный, даже если не-дисковая часть пути является относительной.</li>
                <li>На хостах, не являющихся Windows, любой путь, который начинается с тильды (<code>~</code>), оценивается как истинный.</li>
            </ul>
            <h4>Сравнения</h4>
            <pre><code>if(&lt;variable|string&gt; MATCHES &lt;regex&gt;)</code></pre>
            <p>Истинно, если данная строка или значение переменной соответствует данному регулярному выражению. См. <a href="#">Regex Specification</a> для формата регулярных выражений.</p>
            <p><strong>Новое в версии 3.9:</strong> группы <code>()</code> захватываются в переменные <code>CMAKE_MATCH_&lt;n&gt;</code>.</p>
            <pre><code>if(&lt;variable|string&gt; LESS &lt;variable|string&gt;)</code></pre>
            <p>Истинно, если данная строка или значение переменной интерпретируется как действительное число (как <code>C double</code>) и меньше значения справа.</p>
            <pre><code>if(&lt;variable|string&gt; GREATER &lt;variable|string&gt;)</code></pre>
            <p>Истинно, если данная строка или значение переменной интерпретируется как действительное число (как <code>C double</code>) и больше значения справа.</p>
            <pre><code>if(&lt;variable|string&gt; EQUAL &lt;variable|string&gt;)</code></pre>
            <p>Истинно, если данная строка или значение переменной интерпретируется как действительное число (как <code>C double</code>) и равно значению справа.</p>
            <pre><code>if(&lt;variable|string&gt; LESS_EQUAL &lt;variable|string&gt;)</code></pre>
            <p><strong>Новое в версии 3.7.</strong></p>
            <p>Истинно, если данная строка или значение переменной интерпретируется как действительное число (как <code>C double</code>) и меньше или равно значению справа.</p>
            <pre><code>if(&lt;variable|string&gt; GREATER_EQUAL &lt;variable|string&gt;)</code></pre>
            <p><strong>Новое в версии 3.7.</strong></p>
            <p>Истинно, если данная строка или значение переменной интерпретируется как действительное число (как <code>C double</code>) и больше или равно значению справа.</p>
            <pre><code>if(&lt;variable|string&gt; STRLESS &lt;variable|string&gt;)</code></pre>
            <p>Истинно, если данная строка или значение переменной лексикографически меньше строки или переменной справа.</p>
            <pre><code>if(&lt;variable|string&gt; STRGREATER &lt;variable|string&gt;)</code></pre>
            <p>Истинно, если данная строка или значение переменной лексикографически больше строки или переменной справа.</p>
            <pre><code>if(&lt;variable|string&gt; STREQUAL &lt;variable|string&gt;)</code></pre>
            <p>Истинно, если данная строка или значение переменной лексикографически равно строке или переменной справа.</p>
            <pre><code>if(&lt;variable|string&gt; STRLESS_EQUAL &lt;variable|string&gt;)</code></pre>
            <p><strong>Новое в версии 3.7.</strong></p>
            <p>Истинно, если данная строка или значение переменной лексикографически меньше или равно строке или переменной справа.</p>
            <pre><code>if(&lt;variable|string&gt; STRGREATER_EQUAL &lt;variable|string&gt;)</code></pre>
            <p><strong>Новое в версии 3.7.</strong></p>
            <p>Истинно, если данная строка или значение переменной лексикографически больше или равно строке или переменной справа.</p>
            <h4>Сравнения версий</h4>
            <pre><code>if(&lt;variable|string&gt; VERSION_LESS &lt;variable|string&gt;)</code></pre>
            <p>Покомпонентное сравнение версий, состоящих из целых чисел (формат версии: <code>major[.minor[.patch[.tweak]]]</code>, пропущенные компоненты считаются равными нулю). Любой нецелочисленный компонент версии или нецелочисленная часть компонента версии эффективно обрезает строку в этой точке.</p>
            <pre><code>if(&lt;variable|string&gt; VERSION_GREATER &lt;variable|string&gt;)</code></pre>
            <p>Покомпонентное сравнение версий, состоящих из целых чисел (формат версии: <code>major[.minor[.patch[.tweak]]]</code>, пропущенные компоненты считаются равными нулю). Любой нецелочисленный компонент версии или нецелочисленная часть компонента версии эффективно обрезает строку в этой точке.</p>
            <pre><code>if(&lt;variable|string&gt; VERSION_EQUAL &lt;variable|string&gt;)</code></pre>
            <p>Покомпонентное сравнение версий, состоящих из целых чисел (формат версии: <code>major[.minor[.patch[.tweak]]]</code>, пропущенные компоненты считаются равными нулю). Любой нецелочисленный компонент версии или нецелочисленная часть компонента версии эффективно обрезает строку в этой точке.</p>
            <pre><code>if(&lt;variable|string&gt; VERSION_LESS_EQUAL &lt;variable|string&gt;)</code></pre>
            <p><strong>Новое в версии 3.7.</strong></p>
            <p>Покомпонентное сравнение версий, состоящих из целых чисел (формат версии: <code>major[.minor[.patch[.tweak]]]</code>, пропущенные компоненты считаются равными нулю). Любой нецелочисленный компонент версии или нецелочисленная часть компонента версии эффективно обрезает строку в этой точке.</p>
            <pre><code>if(&lt;variable|string&gt; VERSION_GREATER_EQUAL &lt;variable|string&gt;)</code></pre>
            <p><strong>Новое в версии 3.7.</strong></p>
            <p>Покомпонентное сравнение версий, состоящих из целых чисел (формат версии: <code>major[.minor[.patch[.tweak]]]</code>, пропущенные компоненты считаются равными нулю). Любой нецелочисленный компонент версии или нецелочисленная часть компонента версии эффективно обрезает строку в этой точке.</p>
            <h4>Сравнение путей</h4>
            <pre><code>if(&lt;variable|string&gt; PATH_EQUAL &lt;variable|string&gt;)</code></pre>
            <p><strong>Новое в версии 3.24.</strong></p>
            <p>Сравнивает два пути поэлементно. Путь будет считаться равным только в случае полного совпадения всех элементов. Несколько разделителей пути эффективно сворачиваются в один, но обратные косые черты не преобразуются в прямые косые черты. Никакая другая нормализация пути не выполняется.</p>
            <p>Поэлементное сравнение превосходит строковое сравнение за счет обработки нескольких разделителей пути. В следующем примере выражение оценивается как истинное с <code>PATH_EQUAL</code>, но ложное с <code>STREQUAL</code>:</p>
            <pre><code># comparison is TRUE
        if ("/a//b/c" PATH_EQUAL "/a/b/c")
           ...
        endif()
        
        # comparison is FALSE
        if ("/a//b/c" STREQUAL "/a/b/c")
           ...
        endif()
        </code></pre>
            <p>См. <code>cmake_path(COMPARE)</code> для получения дополнительной информации.</p>
            <h3>Развертывание переменных</h3>
            <p>Команда <code>if</code> была написана на раннем этапе истории CMake, предшествуя синтаксису развертывания переменных <code>${}</code>, и для удобства выполняет оценку переменных, указанных в ее аргументах, как показано в приведенных выше примерах. Обратите внимание, что нормальное развертывание переменных с помощью <code>${}</code> выполняется до того, как команда <code>if</code> получит аргументы. Поэтому код типа</p>
            <pre><code>set(var1 OFF)
        set(var2 "var1")
        if(${var2})</code></pre>
            <p>выглядит для команды <code>if</code> как</p>
            <pre><code>if(var1)</code></pre>
            <p>и оценивается согласно случаю <code>if(&lt;variable&gt;)</code>, описанному выше. Результатом является <code>OFF</code>, что является ложным. Однако если мы уберем <code>${}</code> из примера, команда увидит</p>
            <pre><code>if(var2)</code></pre>
            <p>что истинно, поскольку <code>var2</code> определено как <code>var1</code>, которое не является ложным константой.</p>
            <p>Автоматическая оценка применяется в других случаях, когда синтаксис условия принимает <code>&lt;variable|string&gt;</code>:</p>
            <ul>
                <li>Левый аргумент к <code>MATCHES</code> сначала проверяется на наличие определения переменной. Если это так, используется значение переменной, иначе используется исходное значение.</li>
                <li>Если левый аргумент к <code>MATCHES</code> отсутствует, он возвращает ложь без ошибки</li>
                <li>Оба левых и правых аргумента к <code>LESS</code>, <code>GREATER</code>, <code>EQUAL</code>, <code>LESS_EQUAL</code> и <code>GREATER_EQUAL</code> независимо проверяются на наличие определения переменной. Если это так, используются их определенные значения, иначе используется исходное значение.</li>
                <li>Оба левых и правых аргумента к <code>STRLESS</code>, <code>STRGREATER</code>, <code>STREQUAL</code>, <code>STRLESS_EQUAL</code> и <code>STRGREATER_EQUAL</code> независимо проверяются на наличие определения переменной. Если это так, используются их определенные значения, иначе используется исходное значение.</li>
                <li>Оба левых и правых аргумента к <code>VERSION_LESS</code>, <code>VERSION_GREATER</code>, <code>VERSION_EQUAL</code>, <code>VERSION_LESS_EQUAL</code> и <code>VERSION_GREATER_EQUAL</code> независимо проверяются на наличие определения переменной. Если это так, используются их определенные значения, иначе используется исходное значение.</li>
                <li>Правый аргумент к <code>NOT</code> проверяется на наличие булевой константы. Если это так, используется значение, в противном случае предполагается, что это переменная, и она разыменовывается.</li>
                <li>Левые и правые аргументы к <code>AND</code> и <code>OR</code> независимо проверяются на наличие булевых констант. Если это так, они используются как таковые, иначе предполагается, что это переменные, и они разыменовываются.</li>
            </ul>
            <p><strong>Изменено в версии 3.1:</strong> чтобы предотвратить двусмысленность, потенциальные имена переменных или ключевые слова можно указать в виде аргумента в кавычках или в скобках. Переменная или ключевое слово в кавычках или в скобках будут интерпретироваться как строка и не будут разыменовываться или интерпретироваться. См. политику <code>CMP0054</code>.</p>
            <p>Нет автоматической оценки для переменных среды или кеша. Их значения должны быть указаны как <code>$ENV{&lt;name&gt;}</code> или <code>$CACHE{&lt;name&gt;}</code> везде, где синтаксис условия принимает <code>&lt;variable|string&gt;</code>.</p>
            <h2>См. также</h2>
            <ul>
                <li><a href="#">else()</a></li>
                <li><a href="#">elseif()</a></li>
                <li><a href="#">endif()</a></li>
            </ul>
        </div>
    </div>
</body>

</html>
