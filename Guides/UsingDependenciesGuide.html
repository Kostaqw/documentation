<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Руководство по Зависимостям</title>
    <link href="../lib/bootstrap.min.css" rel="stylesheet">
    <link href="../css/styles.css" rel="stylesheet">

</head>
<header>
    <div class="container-fluid bg-primary text-white py-2">
        <div class="row align-items-center">
            <div class="col-auto">
                <img src="../img/cmake-logo-16.png" alt="Logo" class="img-fluid" style="max-height: 40px;">
            </div>
            <div class="col">
                <nav aria-label="breadcrumb">
                    <ol class="breadcrumb bg-primary text-white mb-0">
                        <li class="breadcrumb-item"><a href="../index.html" class="text-white">Документация</a></li>
                        <li class="breadcrumb-item"><a href="#" class="text-white">Руководство по Зависимостям</a></li>
                    </ol>
                </nav>
            </div>
        </div>
    </div>
</header>

<body>
    <div class="container">
        <div class="container mt-5">
            <h1 class="section-title">Руководство по Зависимостям</h1>
            <ul>
                <li>
                    <h4><a href="#introduction">Введение</a></h4>
                </li>
                <li>
                    <h4><a href="#prebuilt-packages">Использование предварительно собранных пакетов через find_package()</a></h4>
                </li>
                <li>
                    <h4><a href="#fetchcontent">Загрузка и сборка из источника с FetchContent</a></h4>
                </li>
                <li>
                    <h4><a href="#fetchcontent-integration">Интеграция FetchContent и find_package()</a></h4>
                </li>
                <li>
                    <h4><a href="#dependency-providers">Провайдеры зависимостей</a></h4>
                </li>
            </ul>

            <h2 id="introduction" class="section-title">Введение</h2>
            <p>Проекты часто зависят от других проектов, ресурсов и артефактов. CMake предоставляет несколько способов включения таких зависимостей в сборку. Проекты и пользователи могут выбрать методы, которые наилучшим образом соответствуют их потребностям.</p>
            <p>Основные методы включения зависимостей в сборку - это команда <code>find_package()</code> и модуль <code>FetchContent</code>. Модуль <code>FindPkgConfig</code> также иногда используется, хотя он не обладает всей интеграцией двух других методов и не будет обсужден далее в этом руководстве.</p>
            <p>Зависимости также могут быть предоставлены пользовательским поставщиком зависимостей. Это может быть сторонний менеджер пакетов или собственный код, реализованный разработчиком. Поставщики зависимостей сотрудничают с основными методами, упомянутыми выше, чтобы расширить их гибкость.</p>    
        
            <h2 id="prebuilt-packages" class="section-title">Использование предварительно собранных пакетов через find_package()</h2>
            <p>Пакет, необходимый проекту, может уже быть собран и доступен в каком-то месте на системе пользователя. Этот пакет мог быть собран с помощью CMake, или он мог использовать другую систему сборки. Это также может быть просто набор файлов, которые не нужно было собирать. CMake предоставляет команду <code>find_package()</code> для таких случаев. Она ищет в известных местах, а также в дополнительных подсказках и путях, предоставленных проектом или пользователем. Она также поддерживает компоненты пакета и возможность, что пакеты могут быть необязательными. Переменные результата предоставляются, чтобы проект мог настроить собственное поведение в зависимости от того, был ли найден пакет или конкретные компоненты.</p>
    
            <p>В большинстве случаев проекты должны использовать базовую сигнатуру. Чаще всего это будет просто имя пакета, возможно, ограничение по версии и ключевое слово <code>REQUIRED</code>, если зависимость не является необязательной. Также можно указать набор компонентов пакета.</p>
    
            <p>Примеры базовой сигнатуры find_package()</p>
            <pre><code>find_package(Catch2)<br>find_package(GTest REQUIRED)<br>find_package(Boost 1.79 COMPONENTS date_time)</code></pre>
    
            <p>Команда <code>find_package()</code> поддерживает два основных метода поиска:</p>
            <ul>
                <li><strong>Config mode:</strong> С помощью этого метода команда ищет файлы, которые обычно предоставляются самим пакетом. Это более надежный метод, так как детали пакета должны всегда соответствовать пакету.</li>
                <li><strong>Module mode:</strong> Не все пакеты осведомлены о CMake. Многие не предоставляют файлы, необходимые для режима конфигурации. Для таких случаев можно предоставить файл модуля Find, либо проектом, либо CMake. Файл Find модуля обычно представляет собой эвристическую реализацию, которая знает, что пакет обычно предоставляет и как представить этот пакет проекту. Поскольку файлы Find модулей обычно распространяются отдельно от пакета, они не так надежны. Они обычно поддерживаются отдельно и могут следовать разным графикам релизов, поэтому они могут легко устареть.</li>
            </ul>
            <p>В зависимости от используемых аргументов, <code>find_package()</code> может использовать один или оба из вышеупомянутых методов. Ограничив опции только базовой сигнатурой, можно использовать как режим конфигурации, так и модульный режим для удовлетворения зависимости. Наличие других опций может ограничить вызов использованием только одного из двух методов, что может снизить способность команды находить зависимость. См. документацию по <code>find_package()</code> для получения полных сведений об этой сложной теме.</p>
    
            <p>Для обоих методов поиска пользователь также может установить переменные кэша в командной строке <code>cmake(1)</code> или в UI-инструментах <code>ccmake(1)</code> или <code>cmake-gui(1)</code>, чтобы повлиять на поиск и переопределить, где искать пакеты. См. Руководство по Взаимодействию с Пользователем для получения дополнительной информации о том, как устанавливать переменные кэша.</p>

            <h4 class="section-title">Пакеты в формате конфигурационных файлов</h4>
    
            <p>Предпочтительный способ для стороннего поставщика предоставить исполняемые файлы, библиотеки, заголовки и другие файлы для использования с CMake - это предоставить конфигурационные файлы. Это текстовые файлы, поставляемые с пакетом, которые определяют цели CMake, переменные, команды и т.д. Конфигурационный файл - это обычный скрипт CMake, который читается командой <code>find_package()</code>.</p>
        
            <p>Конфигурационные файлы обычно можно найти в каталоге, название которого соответствует шаблону <code>lib/cmake/&lt;PackageName&gt;</code>, хотя они могут быть и в других местах (см. Процедуру Поиска в Режиме Конфигурации). <code>&lt;PackageName&gt;</code> обычно является первым аргументом команды <code>find_package()</code>, и это может быть даже единственный аргумент. Альтернативные имена также можно указать с помощью опции <code>NAMES</code>:</p>
        
            <h4>Предоставление альтернативных имен при поиске пакета</h4>
            <pre><code>find_package(SomeThing<br>          NAMES<br>            SameThingOtherName   # Другое имя для пакета<br>            SomeThing            # Также искать его каноническое имя<br>)</code></pre>
        
            <p>Конфигурационный файл должен быть назван либо <code>&lt;PackageName&gt;Config.cmake</code>, либо <code>&lt;LowercasePackageName&gt;-config.cmake</code> (первый используется в остальной части этого руководства, но оба поддерживаются). Этот файл является точкой входа в пакет для CMake. Также может существовать отдельный необязательный файл с именем <code>&lt;PackageName&gt;ConfigVersion.cmake</code> или <code>&lt;LowercasePackageName&gt;-config-version.cmake</code> в том же каталоге. Этот файл используется CMake для определения того, удовлетворяет ли версия пакета любым ограничениям версии, указанным в вызове <code>find_package()</code>. Указание версии при вызове <code>find_package()</code> является необязательным, даже если файл <code>&lt;PackageName&gt;ConfigVersion.cmake</code> присутствует.</p>
        
            <p>Если файл <code>&lt;PackageName&gt;Config.cmake</code> найден и любое ограничение версии удовлетворено, команда <code>find_package()</code> считает пакет найденным, и весь пакет считается завершенным, как задумано.</p>
        
            <p>Могут быть дополнительные файлы, предоставляющие команды CMake или Импортированные Цели для использования. CMake не требует соблюдения какого-либо соглашения о наименовании для этих файлов. Они связаны с основным файлом <code>&lt;PackageName&gt;Config.cmake</code> с помощью команды <code>include()</code> CMake. Обычно файл <code>&lt;PackageName&gt;Config.cmake</code> включает их для вас, поэтому они обычно не требуют дополнительных шагов, кроме вызова <code>find_package()</code>.</p>
        
            <p>Если местоположение пакета находится в каталоге, известном CMake, вызов <code>find_package()</code> должен быть успешным. Известные CMake каталоги зависят от платформы. Например, пакеты, установленные в Linux с помощью стандартного системного менеджера пакетов, будут автоматически найдены в префиксе <code>/usr</code>. Пакеты, установленные в Program Files на Windows, также будут автоматически найдены.</p>
        
            <p>Пакеты не будут автоматически найдены без помощи, если они находятся в местах, не известных CMake, таких как <code>/opt/mylib</code> или <code>$HOME/dev/prefix</code>. Это обычная ситуация, и CMake предоставляет несколько способов для пользователей указать, где искать такие библиотеки.</p>
        
            <p>Переменная <code>CMAKE_PREFIX_PATH</code> может быть установлена при вызове CMake. Она рассматривается как список базовых путей для поиска конфигурационных файлов. Пакет, установленный в <code>/opt/somepackage</code>, обычно будет устанавливать конфигурационные файлы, такие как <code>/opt/somepackage/lib/cmake/somePackage/SomePackageConfig.cmake</code>. В этом случае <code>/opt/somepackage</code> должно быть добавлено в <code>CMAKE_PREFIX_PATH</code>.</p>
        
            <p>Переменная окружения <code>CMAKE_PREFIX_PATH</code> также может быть заполнена префиксами для поиска пакетов. Как и переменная окружения <code>PATH</code>, это список, но он должен использовать платформо-специфичный разделитель элементов списка (например, <code>:</code> на Unix и <code>;</code> на Windows).</p>
        
            <p>Переменная <code>CMAKE_PREFIX_PATH</code> предоставляет удобство в случаях, когда нужно указать несколько префиксов, или когда несколько пакетов доступны под одним префиксом. Пути к пакетам также можно указать, установив переменные, совпадающие с <code>&lt;PackageName&gt;_DIR</code>, такие как <code>SomePackage_DIR</code>. Обратите внимание, что это не префикс, а полный путь к каталогу, содержащему файл стиля конфигурации пакета, такой как <code>/opt/somepackage/lib/cmake/SomePackage</code> в приведенном выше примере. См. документацию по <code>find_package()</code> для других переменных CMake и переменных окружения, которые могут повлиять на поиск.</p>
        
            <h4 class="section-title">Файлы для модуля поиска</h4>

            <p>Пакеты, которые не предоставляют конфигурационные файлы, все еще могут быть найдены с помощью команды <code>find_package()</code>, если доступен файл <code>FindSomePackage.cmake</code>. Эти файлы модуля поиска отличаются от конфигурационных файлов тем, что:</p>
        
            <ul>
                <li>Файлы модуля поиска не должны предоставляться самим пакетом.</li>
                <li>Наличие файла <code>Find<PackageName>.cmake</code> не указывает на наличие пакета или какой-либо его части.</li>
                <li>CMake не ищет файлы <code>Find<PackageName>.cmake</code> в местах, указанных в переменной <code>CMAKE_PREFIX_PATH</code>. Вместо этого CMake ищет такие файлы в местах, указанных в переменной <code>CMAKE_MODULE_PATH</code>. Пользователи часто устанавливают <code>CMAKE_MODULE_PATH</code> при запуске CMake, и проекты CMake часто добавляют к <code>CMAKE_MODULE_PATH</code>, чтобы использовать локальные файлы модуля поиска.</li>
                <li>CMake поставляет файлы <code>Find<PackageName>.cmake</code> для некоторых сторонних пакетов. Эти файлы являются бременем для CMake и не является необычным, что они отстают от последних релизов связанных с ними пакетов. В целом, новые модули поиска больше не добавляются в CMake. Проекты должны поощрять пакеты upstream предоставлять конфигурационные файлы, где это возможно. Если это не удается, проект должен предоставить свой собственный модуль поиска для пакета.</li>
            </ul>
        
            <p>См. <a href="#find-modules">Find Modules</a> для подробного обсуждения того, как написать файл модуля поиска.</p>
        
            <h4 class="section-title">Импортированные цели</h4>
        
            <p>Как конфигурационные файлы, так и файлы модуля поиска могут определять Импортированные Цели. Обычно они имеют имена вида <code>SomePrefix::ThingName</code>. Где они доступны, проект должен предпочитать использовать их вместо любых переменных CMake, которые также могут быть предоставлены. Такие цели обычно содержат требования к использованию и автоматически применяют такие вещи, как пути поиска заголовков, определения компилятора и т.д. к другим целям, которые ссылаются на них (например, используя <code>target_link_libraries()</code>). Это как более надежно, так и удобнее, чем пытаться применять те же вещи вручную с помощью переменных. Проверьте документацию для пакета или модуля поиска, чтобы узнать, какие импортированные цели он определяет, если таковые имеются.</p>
        
            <p>Импортированные цели также должны инкапсулировать любые пути, специфичные для конфигурации. Это включает местоположение бинарных файлов (библиотек, исполняемых файлов), флаги компилятора и любые другие зависимые от конфигурации количества. Модули поиска могут быть менее надежными в предоставлении этих деталей, чем конфигурационные файлы.</p>
        
            <p>Полный пример, который находит сторонний пакет и использует библиотеку из него, может выглядеть следующим образом:</p>
            
            <pre><code>cmake_minimum_required(VERSION 3.10)<br>project(MyExeProject VERSION 1.0.0)<br># Сделать доступными предоставленные проектом модули поиска<br><br>list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")<br><br>find_package(SomePackage REQUIRED)<br>add_executable(MyExe main.cpp)<br>target_link_libraries(MyExe PRIVATE SomePrefix::LibName)</code></pre>
        
            <p>Обратите внимание, что вызов <code>find_package()</code> выше может быть разрешен как конфигурационным файлом, так и модулем поиска. Он использует только основные аргументы, поддерживаемые Основной Подписью. Файл <code>FindSomePackage.cmake</code> в каталоге <code>${CMAKE_CURRENT_SOURCE_DIR}/cmake</code> позволит команде <code>find_package()</code> успешно выполниться в режиме модуля, например. Если такой модульный файл отсутствует, система будет искать конфигурационный файл.</p>
        
            <h2 id="fetchcontent" class="section-title">Загрузка и сборка из источника с FetchContent</h2>

            <p>Зависимости не обязательно должны быть предварительно собраны, чтобы использовать их с CMake. Их можно собрать из исходных кодов как часть основного проекта. Модуль FetchContent предоставляет функциональность для загрузки содержимого (обычно исходных кодов, но может быть что угодно) и добавления его в основной проект, если зависимость также использует CMake. Исходники зависимости будут собраны вместе с остальной частью проекта, как если бы они были частью исходных кодов самого проекта.</p>
        
            <p>Общий шаблон состоит в том, чтобы проект сначала объявил все зависимости, которые он хочет использовать, а затем запросил их доступность. Следующий пример демонстрирует принцип (см. раздел <a href="#examples">Примеры</a> для получения дополнительной информации):</p>
        
            <pre><code>include(FetchContent)<br>FetchContent_Declare(<br>  googletest<br>  GIT_REPOSITORY https://github.com/google/googletest.git<br>  GIT_TAG        703bd9caab50b139428cea1aaff9974ebee5742e # release-1.10.0<br>)
                <br>FetchContent_Declare(<br>  Catch2<br>  GIT_REPOSITORY https://github.com/catchorg/Catch2.git<br>  GIT_TAG        605a34765aa5d5ecbf476b4598a862ada971b0cc # v3.0.1<br>)
                <br>FetchContent_MakeAvailable(googletest Catch2)</code></pre>
        
            <p>Поддерживаются различные методы загрузки, включая загрузку и извлечение архивов по URL (поддерживается ряд форматов архивов) и несколько форматов репозиториев, включая Git, Subversion и Mercurial. Также могут использоваться пользовательские команды для загрузки, обновления и патчинга, чтобы поддерживать произвольные случаи использования.</p>
        
            <p>Когда зависимость добавляется в проект с помощью FetchContent, проект связывается с целями зависимости так же, как и с любыми другими целями проекта. Если зависимость предоставляет именные цели вида <code>SomePrefix::ThingName</code>, проект должен связываться с ними, а не с любыми неименованными целями. См. следующий раздел, чтобы понять, почему это рекомендуется.</p>
        
            <p>Не все зависимости могут быть добавлены в проект таким образом. Некоторые зависимости определяют цели, имена которых конфликтуют с другими целями проекта или другими зависимостями. Конкретные цели исполняемых файлов и библиотек, созданные с помощью <code>add_executable()</code> и <code>add_library()</code>, являются глобальными, поэтому каждая из них должна быть уникальной по всему сбору. Если зависимость добавляет конфликтующее имя цели, ее нельзя напрямую включить в сборку этим методом.</p>
        
            <h2 id="fetchcontent-integration" class="section-title">Интеграция FetchContent и find_package()</h2>
        
            <p><strong>Новая функция в версии 3.24.</strong></p>
        
            <p>Некоторые зависимости поддерживают добавление как с помощью <code>find_package()</code>, так и с помощью FetchContent. Такие зависимости должны обеспечить определение одинаковых именных целей как в установленных, так и в собранных из исходного кода сценариях. Проект, который использует эти именные цели, может обрабатывать оба сценария прозрачно, если проект не использует ничего другого, что не предоставляется обоими методами.</p>
        
            <p>Проект может указать, что он готов принять зависимость любым из методов, используя опцию <code>FIND_PACKAGE_ARGS</code> для <code>FetchContent_Declare()</code>. Это позволяет <code>FetchContent_MakeAvailable()</code> сначала попытаться удовлетворить зависимость вызовом <code>find_package()</code> с использованием аргументов после ключевого слова <code>FIND_PACKAGE_ARGS</code>, если таковые имеются. Если это не найдет зависимость, она будет собрана из исходного кода, как описано ранее.</p>
        
            <pre><code>include(FetchContent)<br>FetchContent_Declare(<br>  googletest<br>  GIT_REPOSITORY https://github.com/google/googletest.git<br>  GIT_TAG        703bd9caab50b139428cea1aaff9974ebee5742e # release-1.10.0<br>  FIND_PACKAGE_ARGS NAMES GTest<br>)
                <br>FetchContent_MakeAvailable(googletest)<br><br>add_executable(ThingUnitTest thing_ut.cpp)<br>target_link_libraries(ThingUnitTest GTest::gtest_main)</code></pre>
        
            <p>В приведенном выше примере сначала вызывается <code>find_package(googletest NAMES GTest)</code>. CMake предоставляет модуль FindGTest, поэтому если он найдет установленный пакет GTest, он будет доступен, и зависимость не будет собрана из исходного кода. Если пакет GTest не найден, он будет собран из исходного кода. В любом случае, ожидается, что цель <code>GTest::gtest_main</code> будет определена, поэтому мы связываем наш исполняемый файл юнит-тестов с этой целью.</p>
        
            <p>Высокий уровень управления также доступен через переменную <code>FETCHCONTENT_TRY_FIND_PACKAGE_MODE</code>. Ее можно установить в <code>NEVER</code>, чтобы отключить все перенаправления на <code>find_package()</code>. Ее можно установить в <code>ALWAYS</code>, чтобы всегда пытаться <code>find_package()</code>, даже если <code>FIND_PACKAGE_ARGS</code> не был указан (это следует использовать с осторожностью).</p>
        
            <p>Проект также может решить, что конкретная зависимость должна быть собрана из исходного кода. Это может потребоваться, если требуется исправленная или не выпущенная версия зависимости, или чтобы удовлетворить некоторую политику, требующую сборки всех зависимостей из исходного кода. Проект может обеспечить это, добавив ключевое слово <code>OVERRIDE_FIND_PACKAGE</code> к <code>FetchContent_Declare()</code>. В этом случае вызов <code>find_package()</code> для этой зависимости будет перенаправлен на <code>FetchContent_MakeAvailable()</code>.</p>
        
            <pre><code>include(FetchContent)<br>FetchContent_Declare(<br>  Catch2<br>  URL https://intranet.mycomp.com/vendored/Catch2_2.13.4_patched.tgz<br>  URL_HASH MD5=abc123...<br>  OVERRIDE_FIND_PACKAGE<br>)<br>
                <br># Следующее автоматически перенаправляется на FetchContent_MakeAvailable(Catch2)<br>find_package(Catch2)</code></pre>
        
            <p>Для более сложных случаев использования см. переменную <code>CMAKE_FIND_PACKAGE_REDIRECTS_DIR</code>.</p>
        
            <h2 id="dependency-providers" class="section-title">Провайдеры зависимостей</h2>

            <p><strong>Новая функция в версии 3.24.</strong></p>
        
            <p>В предыдущем разделе обсуждались методы, которые проекты могут использовать для указания своих зависимостей. В идеале, проекту не должно быть важно, откуда поступает зависимость, если она предоставляет необходимые вещи (часто просто импортированные цели). Проект указывает, что ему нужно, и может также указать, откуда это взять, при отсутствии других деталей, чтобы его все еще можно было собрать "из коробки".</p>
        
            <p>С другой стороны, разработчик может быть гораздо более заинтересован в контроле над тем, как зависимость предоставляется проекту. Вы можете захотеть использовать конкретную версию пакета, которую вы собрали сами. Возможно, вы захотите использовать сторонний менеджер пакетов. Вы можете захотеть перенаправить некоторые запросы на другой URL на системе, которую вы контролируете, по соображениям безопасности или производительности. CMake поддерживает такие сценарии через провайдеров зависимостей.</p>
        
            <p>Провайдер зависимости может быть настроен на перехват вызовов <code>find_package()</code> и <code>FetchContent_MakeAvailable()</code>. Провайдер получает возможность удовлетворить такие запросы перед тем, как будет использована встроенная реализация, если провайдер не удовлетворит запрос.</p>
        
            <p>Только один провайдер зависимости может быть установлен, и его можно установить только в очень определенный момент на раннем этапе выполнения CMake. Переменная <code>CMAKE_PROJECT_TOP_LEVEL_INCLUDES</code> перечисляет файлы CMake, которые будут прочитаны при обработке первого вызова <code>project()</code> (и только этого вызова). Это единственное время, когда может быть установлен провайдер зависимости. Ожидается, что на протяжении всего проекта будет использоваться не более одного провайдера.</p>
        
            <p>В некоторых сценариях пользователю не нужно знать детали того, как установлен провайдер зависимости. Сторонняя организация может предоставить файл, который можно добавить в <code>CMAKE_PROJECT_TOP_LEVEL_INCLUDES</code>, чтобы настроить провайдера зависимости от имени пользователя. Это рекомендованный подход для менеджеров пакетов. Разработчик может использовать такой файл следующим образом:</p>
        
            <pre><code>cmake -DCMAKE_PROJECT_TOP_LEVEL_INCLUDES=/path/to/package_manager/setup.cmake ...</code></pre>
        
            <p>Для получения подробной информации о том, как реализовать собственный провайдер зависимости, см. команду <code>cmake_language(SET_DEPENDENCY_PROVIDER)</code>.</p>
        
        </div>
    </div>
</body>

<footer>
    <div class="container-fluid bg-primary text-white py-2">
        <div class="row align-items-center">
            <div class="col-auto">
                <img src="../img/cmake-logo-16.png" alt="Logo" class="img-fluid" style="max-height: 40px;">
            </div>
            <div class="col">
                <nav aria-label="breadcrumb">
                    <ol class="breadcrumb bg-primary text-white mb-0">
                        <li class="breadcrumb-item"><a href="../index.html" class="text-white">Документация</a></li>
                        <li class="breadcrumb-item"><a href="#" class="text-white">Руководство по Зависимостям</a></li>
                    </ol>
                </nav>
            </div>
        </div>
    </div>
</footer>

<script src="../js/jquery-3.5.1.min.js"></script>
<script src="../js/popper.min.js"></script>
<script src="../js/bootstrap.min.js"></script>
<script src="../js/scripts.js"></script>

</html>